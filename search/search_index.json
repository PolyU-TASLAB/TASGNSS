{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TASGNSS","text":"<p>This is a GNSS positioning utility that implements Weighted Least Squares (WLS) positioning algorithm.</p>"},{"location":"#overview","title":"Overview","text":"<p>The tool processes GNSS observations to calculate receiver position, velocity, and clock parameters using WLS method. It supports multiple GNSS systems and includes necessary corrections for practical applications.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Weighted Least Squares positioning</li> <li>Support for multiple GNSS constellations</li> <li>Atmospheric delay corrections (ionospheric and tropospheric)</li> <li>Satellite clock and relativistic effects correction</li> <li>Iterative solution until convergence</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed technical information about the WLS algorithm and GNSS corrections, please see the Appendix.</p>"},{"location":"api/","title":"TASGNSS API Documents","text":""},{"location":"api/#tasgnss.Backend","title":"<code>Backend</code>","text":"Source code in <code>tasgnss/core.py</code> <pre><code>class Backend:\n    def __init__(self, use_torch=False):\n        self.use_torch = use_torch\n        if use_torch:\n            try:\n                import torch\n                self.torch = torch\n                self.np = np\n            except ImportError:\n                print(\"Please install pytorch to enable the torch-based WLS\")\n                self.use_torch = False\n                self.torch = None\n                self.np = np\n        else:\n            self.torch = None\n            self.np = np\n\n    def array(self, data, dtype=None):\n        if self.use_torch and self.torch is not None:\n            return self.torch.tensor(data, dtype=dtype)\n        else:\n            return self.np.array(data, dtype=dtype)\n\n    def zeros(self, shape, dtype=None):\n        if self.use_torch and self.torch is not None:\n            return self.torch.zeros(shape, dtype=dtype)\n        else:\n            return self.np.zeros(shape, dtype=dtype)\n\n    def ones(self, shape, dtype=None):\n        if self.use_torch and self.torch is not None:\n            return self.torch.ones(shape, dtype=dtype)\n        else:\n            return self.np.ones(shape, dtype=dtype)\n\n    def eye(self, n, dtype=None):\n        if self.use_torch and self.torch is not None:\n            return self.torch.eye(n, dtype=dtype)\n        else:\n            return self.np.eye(n, dtype=dtype)\n\n    def diag(self, v):\n        if self.use_torch and self.torch is not None:\n            return self.torch.diag(v)\n        else:\n            return self.np.diag(v)\n\n    def linalg_norm(self, x, axis=None):\n        if self.use_torch and self.torch is not None:\n            return self.torch.linalg.norm(x, dim=axis)\n        else:\n            return self.np.linalg.norm(x, axis=axis)\n\n    def linalg_lstsq(self, A, B, rcond=None):\n        if self.use_torch and self.torch is not None:\n            return [self.torch.pinv(A) @ B]\n        else:\n            return self.np.linalg.lstsq(A, B, rcond=rcond)\n\n    def reshape(self, x, shape):\n        if self.use_torch and self.torch is not None:\n            return x.reshape(shape)\n        else:\n            return self.np.reshape(x, shape)\n\n    def squeeze(self, x, axis=None):\n        if self.use_torch and self.torch is not None:\n            if axis is None:\n                return self.torch.squeeze(x)  # \u4e0d\u4f20 dim \u53c2\u6570\uff0c\u8ba9 PyTorch \u81ea\u52a8\u5904\u7406\n            else:\n                return self.torch.squeeze(x, dim=axis)\n        else:\n            return self.np.squeeze(x, axis=axis)\n\n    def any(self, x, axis=None):\n        if self.use_torch and self.torch is not None:\n            return self.torch.any(x, dim=axis)\n        else:\n            return self.np.any(x, axis=axis)\n\n    def unique(self, x, return_counts=False):\n        if self.use_torch and self.torch is not None:\n            if return_counts:\n                return self.torch.unique(x, return_counts=True)\n            else:\n                return self.torch.unique(x)\n        else:\n            return self.np.unique(x, return_counts=return_counts)\n\n    def sqrt(self, x):\n        if self.use_torch and self.torch is not None:\n            return self.torch.sqrt(x)\n        else:\n            return self.np.sqrt(x)\n\n    def sin(self, x):\n        if self.use_torch and self.torch is not None:\n            return self.torch.sin(x)\n        else:\n            return self.np.sin(x)\n\n    def cos(self, x):\n        if self.use_torch and self.torch is not None:\n            return self.torch.cos(x)\n        else:\n            return self.np.cos(x)\n\n    def arctan2(self, y, x):\n        if self.use_torch and self.torch is not None:\n            return self.torch.atan2(y, x)\n        else:\n            return self.np.arctan2(y, x)\n\n    def degrees(self, x):\n        if self.use_torch and self.torch is not None:\n            return self.torch.rad2deg(x)\n        else:\n            return self.np.degrees(x)\n\n    def radians(self, x):\n        if self.use_torch and self.torch is not None:\n            return self.torch.deg2rad(x)\n        else:\n            return self.np.radians(x)\n\n    def where(self, condition, x, y):\n        if self.use_torch and self.torch is not None:\n            return self.torch.where(condition, x, y)\n        else:\n            return self.np.where(condition, x, y)\n\n    def sum(self, x, axis=None):\n        if self.use_torch and self.torch is not None:\n            return self.torch.sum(x, dim=axis)\n        else:\n            return self.np.sum(x, axis=axis)\n\n    def dot(self, a, b):\n        if self.use_torch and self.torch is not None:\n            return self.torch.matmul(a, b)\n        else:\n            return self.np.dot(a, b)\n\n    def transpose(self, x):\n        if self.use_torch and self.torch is not None:\n            return x.T\n        else:\n            return self.np.transpose(x)\n\n    def stack(self, arrays, axis=0):\n        if self.use_torch and self.torch is not None:\n            return self.torch.stack(arrays, dim=axis)\n        else:\n            return self.np.stack(arrays, axis=axis)\n\n    def vstack(self, arrays):\n        if self.use_torch and self.torch is not None:\n            return self.torch.vstack(arrays)\n        else:\n            return self.np.vstack(arrays)\n\n    def hstack(self, arrays):\n        if self.use_torch and self.torch is not None:\n            return self.torch.hstack(arrays)\n        else:\n            return self.np.hstack(arrays)\n\n    def concatenate(self, arrays, axis=0):\n        if self.use_torch and self.torch is not None:\n            return self.torch.cat(arrays, dim=axis)\n        else:\n            return self.np.concatenate(arrays, axis=axis)\n\n    def copy(self, x):\n        if self.use_torch and self.torch is not None:\n            return x.clone()\n        else:\n            return self.np.copy(x)\n\n    def asarray(self, x, dtype=None):\n        if self.use_torch and self.torch is not None:\n            return self.torch.as_tensor(x, dtype=dtype)\n        else:\n            return self.np.asarray(x, dtype=dtype)\n\n    def is_tensor(self, x):\n        if self.use_torch and self.torch is not None:\n            return isinstance(x, self.torch.Tensor)\n        else:\n            return isinstance(x, self.np.ndarray)\n\n    def to_numpy(self, x):\n        if self.use_torch and self.torch is not None and isinstance(x, self.torch.Tensor):\n            return x.detach().cpu().numpy()\n        else:\n            return x\n\n    def from_numpy(self, x):\n        if self.use_torch and self.torch is not None:\n            return self.torch.from_numpy(x)\n        else:\n            return x\n\n    def requires_grad_(self, x, requires_grad=True):\n        if self.use_torch and self.torch is not None and isinstance(x, self.torch.Tensor):\n            return x.requires_grad_(requires_grad)\n        else:\n            return x\n\n    def grad(self, x):\n        if self.use_torch and self.torch is not None and isinstance(x, self.torch.Tensor):\n            return x.grad\n        else:\n            return None\n\n    def no_grad(self):\n        if self.use_torch and self.torch is not None:\n            return self.torch.no_grad()\n        else:\n            class NoGrad:\n                def __enter__(self):\n                    pass\n                def __exit__(self, exc_type, exc_val, exc_tb):\n                    pass\n            return NoGrad()\n\n    def zeros_like(self, x, dtype=None):\n        if self.use_torch and self.torch is not None:\n            return self.torch.zeros_like(x, dtype=dtype)\n        else:\n            return self.np.zeros_like(x, dtype=dtype)\n\n    def block_diag(self, *arrays):\n        \"\"\"\n        Create a block diagonal matrix from provided arrays.\n        \"\"\"\n        if self.use_torch and self.torch is not None:\n            return self.torch.block_diag(*arrays)\n        else:\n            # Manual implementation for NumPy\n            if len(arrays) == 0:\n                return self.np.array([])\n            # Calculate total shape\n            total_rows = sum(arr.shape[0] for arr in arrays)\n            total_cols = sum(arr.shape[1] for arr in arrays)\n            result = self.np.zeros((total_rows, total_cols))\n            row_offset = 0\n            col_offset = 0\n            for arr in arrays:\n                rows, cols = arr.shape\n                result[row_offset:row_offset + rows, col_offset:col_offset + cols] = arr\n                row_offset += rows\n                col_offset += cols\n            return result\n\n    def astype(self, tensor_or_array, dtype):\n        \"\"\"\n        Convert the data type of the input array/tensor.\n        Automatically dispatches to torch.to(dtype) or np.astype(dtype)\n        \"\"\"\n        if self.use_torch and self.torch is not None:\n            return tensor_or_array.to(dtype)\n        else:\n            return tensor_or_array.astype(dtype)\n\n    def to(self, tensor_or_array, device):\n        \"\"\"\n        Move tensor to device (if using torch), or do nothing (if using numpy).\n        \"\"\"\n        if self.use_torch and self.torch is not None:\n            return tensor_or_array.to(device)\n        else:\n            return tensor_or_array\n\n    # ========== \u5e38\u7528\u6570\u636e\u7c7b\u578b\u5c5e\u6027 ==========\n\n    @property\n    def float16(self):\n        return self.torch.float16 if self.use_torch else self.np.float16\n\n    @property\n    def float32(self):\n        return self.torch.float32 if self.use_torch else self.np.float32\n\n    @property\n    def float64(self):\n        return self.torch.float64 if self.use_torch else self.np.float64\n\n    @property\n    def int8(self):\n        return self.torch.int8 if self.use_torch else self.np.int8\n\n    @property\n    def int16(self):\n        return self.torch.int16 if self.use_torch else self.np.int16\n\n    @property\n    def int32(self):\n        return self.torch.int32 if self.use_torch else self.np.int32\n\n    @property\n    def int64(self):\n        return self.torch.int64 if self.use_torch else self.np.int64\n\n    @property\n    def uint8(self):\n        return self.torch.uint8 if self.use_torch else self.np.uint8\n\n    @property\n    def bool(self):\n        return self.torch.bool if self.use_torch else self.np.bool_\n\n    @property\n    def complex64(self):\n        return self.torch.complex64 if self.use_torch else self.np.complex64\n\n    @property\n    def complex128(self):\n        return self.torch.complex128 if self.use_torch else self.np.complex128\n</code></pre>"},{"location":"api/#tasgnss.Backend.astype","title":"<code>astype(tensor_or_array, dtype)</code>","text":"<p>Convert the data type of the input array/tensor. Automatically dispatches to torch.to(dtype) or np.astype(dtype)</p> Source code in <code>tasgnss/core.py</code> <pre><code>def astype(self, tensor_or_array, dtype):\n    \"\"\"\n    Convert the data type of the input array/tensor.\n    Automatically dispatches to torch.to(dtype) or np.astype(dtype)\n    \"\"\"\n    if self.use_torch and self.torch is not None:\n        return tensor_or_array.to(dtype)\n    else:\n        return tensor_or_array.astype(dtype)\n</code></pre>"},{"location":"api/#tasgnss.Backend.block_diag","title":"<code>block_diag(*arrays)</code>","text":"<p>Create a block diagonal matrix from provided arrays.</p> Source code in <code>tasgnss/core.py</code> <pre><code>def block_diag(self, *arrays):\n    \"\"\"\n    Create a block diagonal matrix from provided arrays.\n    \"\"\"\n    if self.use_torch and self.torch is not None:\n        return self.torch.block_diag(*arrays)\n    else:\n        # Manual implementation for NumPy\n        if len(arrays) == 0:\n            return self.np.array([])\n        # Calculate total shape\n        total_rows = sum(arr.shape[0] for arr in arrays)\n        total_cols = sum(arr.shape[1] for arr in arrays)\n        result = self.np.zeros((total_rows, total_cols))\n        row_offset = 0\n        col_offset = 0\n        for arr in arrays:\n            rows, cols = arr.shape\n            result[row_offset:row_offset + rows, col_offset:col_offset + cols] = arr\n            row_offset += rows\n            col_offset += cols\n        return result\n</code></pre>"},{"location":"api/#tasgnss.Backend.to","title":"<code>to(tensor_or_array, device)</code>","text":"<p>Move tensor to device (if using torch), or do nothing (if using numpy).</p> Source code in <code>tasgnss/core.py</code> <pre><code>def to(self, tensor_or_array, device):\n    \"\"\"\n    Move tensor to device (if using torch), or do nothing (if using numpy).\n    \"\"\"\n    if self.use_torch and self.torch is not None:\n        return tensor_or_array.to(device)\n    else:\n        return tensor_or_array\n</code></pre>"},{"location":"api/#tasgnss.covecef","title":"<code>covecef(pos, Q)</code>","text":"<p>Convert covariance from ENU to ECEF Parameters:     pos: tuple or array of (lat, lon) in degrees     Q: 3x3 covariance matrix in ENU frame Returns:     Q_ecef: 3x3 covariance matrix in ECEF frame</p> Source code in <code>tasgnss/core.py</code> <pre><code>def covecef(pos, Q):\n    \"\"\"\n    Convert covariance from ENU to ECEF\n    Parameters:\n        pos: tuple or array of (lat, lon) in degrees\n        Q: 3x3 covariance matrix in ENU frame\n    Returns:\n        Q_ecef: 3x3 covariance matrix in ECEF frame\n    \"\"\"\n    E = xyz2enu(pos)\n    return E.T @ Q @ E\n</code></pre>"},{"location":"api/#tasgnss.doppler_observe_func","title":"<code>doppler_observe_func(vel, dT, pos, satpos, satvel, sdT, sys, enable_torch=False, device='cpu')</code>","text":"<p>Computes Doppler (range-rate) observation residuals and their Jacobian matrix for GNSS velocity estimation. This function models the geometric relative velocity, Earth rotation (Sagnac) correction, and receiver-satellite clock drift difference. The state vector assumed is: [vx, vy, vz, dT] \u2014 velocity + public clock drift (no position or clock bias). Clock bias is handled externally (e.g., in pseudorange module), enabling modular design via block_diag fusion.</p> <p>Parameters: vel : receiver velocity vector, shape (3,) dT : public pseudorange rate for all systems, shape (1,), unit: m/s pos : approximate receiver position (ECEF), shape (3,) \u2014 precision ~100m sufficient satpos : satellite positions (ECEF), shape (n_obs, 3) satvel : satellite velocities (ECEF), shape (n_obs, 3) sdT : satellite clock drifts (from broadcast/SP3), shape (n_obs,), unit: s/s sys : list of GNSS system identifiers for each observation, e.g., ['G', 'E', 'C'] enable_torch : if True, use PyTorch backend for computations device : if enable_torch is True, specifies the device ('cpu' or 'cuda')</p> <p>Returns: v : predicted Doppler velocity residuals (m/s), shape (n_obs, 1) H : Jacobian matrix w.r.t state [vx, vy, vz, dT], shape (n_obs, 4)</p> Source code in <code>tasgnss/core.py</code> <pre><code>def doppler_observe_func(vel, dT, pos, satpos, satvel, sdT, sys, enable_torch=False, device='cpu'):\n    \"\"\"\n    Computes Doppler (range-rate) observation residuals and their Jacobian matrix for GNSS velocity estimation.\n    This function models the geometric relative velocity, Earth rotation (Sagnac) correction, and receiver-satellite clock drift difference.\n    The state vector assumed is: [vx, vy, vz, dT] \u2014 velocity + public clock drift (no position or clock bias).\n    Clock bias is handled externally (e.g., in pseudorange module), enabling modular design via block_diag fusion.\n\n    Parameters:\n    vel : receiver velocity vector, shape (3,)\n    dT : public pseudorange rate for all systems, shape (1,), unit: m/s\n    pos : approximate receiver position (ECEF), shape (3,) \u2014 precision ~100m sufficient\n    satpos : satellite positions (ECEF), shape (n_obs, 3)\n    satvel : satellite velocities (ECEF), shape (n_obs, 3)\n    sdT : satellite clock drifts (from broadcast/SP3), shape (n_obs,), unit: s/s\n    sys : list of GNSS system identifiers for each observation, e.g., ['G', 'E', 'C']\n    enable_torch : if True, use PyTorch backend for computations\n    device : if enable_torch is True, specifies the device ('cpu' or 'cuda')\n\n    Returns:\n    v : predicted Doppler velocity residuals (m/s), shape (n_obs, 1)\n    H : Jacobian matrix w.r.t state [vx, vy, vz, dT], shape (n_obs, 4)\n    \"\"\"\n    backend = Backend(enable_torch)\n\n    # \u8f6c\u6362\u6240\u6709\u8f93\u5165\u4e3a float64 \u5e76\u79fb\u52a8\u5230 device\n    dT = backend.asarray(dT, dtype=backend.float64)\n    pos = backend.asarray(pos, dtype=backend.float64)\n    satpos = backend.asarray(satpos, dtype=backend.float64)\n    satvel = backend.asarray(satvel, dtype=backend.float64)\n    sdT = backend.asarray(sdT, dtype=backend.float64)\n\n    vel = backend.to(vel, device)\n    dT = backend.to(dT, device)\n    pos = backend.to(pos, device)\n    satpos = backend.to(satpos, device)\n    satvel = backend.to(satvel, device)\n    sdT = backend.to(sdT, device)\n\n    # \u8ba1\u7b97\u5355\u4f4d\u5411\u91cf e\n    diff = satpos - pos  # shape: (n_obs, 3)\n    norm = backend.linalg_norm(diff, axis=1).reshape(-1, 1)  # shape: (n_obs, 1)\n    e = -diff / norm  # shape: (n_obs, 3)\n\n    # \u51e0\u4f55\u76f8\u5bf9\u901f\u5ea6\u9879\n    rel_vel = satvel - vel  # shape: (n_obs, 3)\n    v1 = -backend.sum(e * rel_vel, axis=1)  # shape: (n_obs,)\n\n    # Sagnac \u4fee\u6b63\u9879\n    v2 = prl.OMGE / prl.CLIGHT * (\n        satvel[:, 1] * pos[0] - satvel[:, 0] * pos[1] +\n        satpos[:, 1] * vel[0] - satpos[:, 0] * vel[1]\n    )  # shape: (n_obs,)\n\n    # \u949f\u5dee\u9879\n    v_clock = dT - prl.CLIGHT * sdT  # shape: (n_obs,)\n\n    # \u603b Doppler \u9884\u6d4b\u503c\n    v = v1 + v2 + v_clock  # shape: (n_obs,)\n    v = v.reshape(-1, 1)  # shape: (n_obs, 1)\n\n\n    # \u6784\u9020 Jacobian H: [\u2202v/\u2202vx, \u2202v/\u2202vy, \u2202v/\u2202vz, \u2202v/\u2202dT]\n    H_t = backend.ones(len(e), dtype=backend.float64).reshape(-1, 1)  # shape: (n_obs, 1)\n    H_t = backend.to(H_t, device)\n    H = backend.hstack((e, H_t))  # shape: (n_obs, 4)\n\n    return v, H\n</code></pre>"},{"location":"api/#tasgnss.ecef_to_enu_direct","title":"<code>ecef_to_enu_direct(satpos, recv_pos)</code>","text":"<p>Convert satellite ECEF coordinates to receiver ENU coordinate system. Parameters:     satpos : ndarray         Satellite ECEF coordinates (n, 3)     recv_pos : ndarray         Receiver ECEF coordinates (1, 3) Returns:     enu : ndarray         Satellite ENU coordinates (n, 3)</p> Source code in <code>tasgnss/core.py</code> <pre><code>def ecef_to_enu_direct(satpos, recv_pos):\n    \"\"\"\n    Convert satellite ECEF coordinates to receiver ENU coordinate system.\n    Parameters:\n        satpos : ndarray\n            Satellite ECEF coordinates (n, 3)\n        recv_pos : ndarray\n            Receiver ECEF coordinates (1, 3)\n    Returns:\n        enu : ndarray\n            Satellite ENU coordinates (n, 3)\n    \"\"\"\n    # Step 1: Calculate the latitude and longitude of the receiver\n    lat, lon, _ = p3d.ecef2geodetic(recv_pos[0], recv_pos[1], recv_pos[2])\n    # Step 2: Calculate the relative vector from satellite to receiver (u, v, w)\n    rel_pos = satpos - recv_pos  # (n, 3)\n    # Step 3: Construct the rotation matrix from ECEF to ENU\n    sin_lat, cos_lat = np.sin(np.radians(lat)), np.cos(np.radians(lat))\n    sin_lon, cos_lon = np.sin(np.radians(lon)), np.cos(np.radians(lon))\n    R = np.array([\n        [-sin_lon, cos_lon, 0],\n        [-sin_lat * cos_lon, -sin_lat * sin_lon, cos_lat],\n        [cos_lat * cos_lon, cos_lat * sin_lon, sin_lat]\n    ])\n    # Step 4: Batch convert to ENU coordinates\n    enu = rel_pos @ R.T  # Matrix multiplication\n    return enu\n</code></pre>"},{"location":"api/#tasgnss.enu_to_azel","title":"<code>enu_to_azel(enu, degree=False)</code>","text":"<p>Convert ENU coordinates to azimuth and elevation angles. Parameters:     enu : ndarray         ENU coordinates (n, 3), each row represents [E, N, U] Returns:     azimuth : ndarray         Azimuth angle array (n,)     elevation : ndarray         Elevation angle array (n,)</p> Source code in <code>tasgnss/core.py</code> <pre><code>def enu_to_azel(enu, degree=False):\n    \"\"\"\n    Convert ENU coordinates to azimuth and elevation angles.\n    Parameters:\n        enu : ndarray\n            ENU coordinates (n, 3), each row represents [E, N, U]\n    Returns:\n        azimuth : ndarray\n            Azimuth angle array (n,)\n        elevation : ndarray\n            Elevation angle array (n,)\n    \"\"\"\n    E, N, U = enu[:, 0], enu[:, 1], enu[:, 2]\n\n    # Calculate azimuth\n    azimuth = np.arctan2(E, N)  # Return value range [-pi, pi]\n    #azimuth = np.degrees(azimuth)  # Convert to degrees\n    azimuth = (azimuth + 2*np.pi) % (2*np.pi)  # Ensure range in [0, 360]\n\n    # Calculate elevation\n    horizontal_distance = np.sqrt(E**2 + N**2)  # Horizontal distance\n    elevation = np.arctan2(U, horizontal_distance)  # Return value range [-pi/2, pi/2]\n    #elevation = np.degrees(elevation)  # Convert to degrees\n    if not degree:\n        return azimuth, elevation\n    else:\n        return np.degrees(azimuth), np.degrees(elevation)\n</code></pre>"},{"location":"api/#tasgnss.get_atmosphere_error","title":"<code>get_atmosphere_error(gtime, satpos, satprns, nav, p)</code>","text":"<p>Computes modeled atmospheric delay errors (ionospheric, tropospheric) and associated observation variances for a set of satellites at a given epoch. Designed for use in GNSS positioning and quality control \u2014 especially in multipath-prone environments like urban canyons.</p> This function uses RTKLIB\u2019s built-in models: <p>Ionosphere: IONOOPT_BRDC (broadcast Klobuchar model) Troposphere: TROPOPT_SAAS (Saastamoinen model)</p> <p>gtime (gtime_t):     Epoch time in RTKLIB\u2019s internal time format.</p> <p>satpos (List[ArrayLike] or ndarray of shape (n, 6)):     Satellite positions and velocities for each satellite, packed as [x, y, z, vx, vy, vz] (ECEF, meters and m/s).</p> <p>satprns (List[int]):     List of satellite PRN numbers (e.g., [1, 5, 12, 19]).</p> <p>nav (nav_t):     Navigation data structure containing ionospheric/tropospheric model parameters (e.g., broadcast iono coeffs).</p> <p>p (ArrayLike, length=3):     Receiver approximate position in ECEF coordinates [X, Y, Z] (meters). Used to compute elevation/azimuth and atmospheric delays.</p> <p>iono_error (ndarray, shape=(n,)):     The modeled ionospheric delay per satellite: dion (meters).</p> <p>trop_error (ndarray, shape=(n,)):     The modeled tropospheric delay per satellite: dtrp (meters).</p> <p>var_el (ndarray, shape=(n,)):     Elevation-dependent variance (empirical model, e.g., for multipath suppression in urban canyons). Computed via RTKLIBvar(azel[1], sys).</p> <p>var_iono (ndarray, shape=(n,)):     Broadcast ionospheric model variance (squared standard deviation, m\u00b2), output from ionocorr.</p> <p>var_tropo (ndarray, shape=(n,)):     Saastamoinen tropospheric model variance (m\u00b2), output from tropcorr.</p> Processing Steps <p>Converts receiver ECEF position p to geodetic coordinates (pos) using ecef2pos. For each satellite:     Computes line-of-sight vector and satellite elevation/azimuth using geodist and satazel.     Calculates ionospheric delay (dion) and its variance (vion) via ionocorr(..., IONOOPT_BRDC, ...).     Calculates tropospheric delay (dtrp) and its variance (vtrp) via tropcorr(..., TROPOPT_SAAS, ...).     Computes elevation-based variance (vel) using RTKLIBvar(elevation, system) \u2014 useful for downweighting low-elevation satellites. Returns arrays of total atmospheric error and component variances.</p> Source code in <code>tasgnss/core.py</code> <pre><code>def get_atmosphere_error(gtime, satpos, satprns, nav, p):\n    \"\"\"\n    Computes modeled atmospheric delay errors (ionospheric, tropospheric) and associated observation variances for a set of satellites at a given epoch.\n    Designed for use in GNSS positioning and quality control \u2014 especially in multipath-prone environments like urban canyons.\n\n    Note: This function uses RTKLIB\u2019s built-in models:\n        Ionosphere: IONOOPT_BRDC (broadcast Klobuchar model)\n        Troposphere: TROPOPT_SAAS (Saastamoinen model)\n\n    Parameters:\n    gtime (gtime_t):\n        Epoch time in RTKLIB\u2019s internal time format.\n\n    satpos (List[ArrayLike] or ndarray of shape (n, 6)):\n        Satellite positions and velocities for each satellite, packed as [x, y, z, vx, vy, vz] (ECEF, meters and m/s).\n\n    satprns (List[int]):\n        List of satellite PRN numbers (e.g., [1, 5, 12, 19]).\n\n    nav (nav_t):\n        Navigation data structure containing ionospheric/tropospheric model parameters (e.g., broadcast iono coeffs).\n\n    p (ArrayLike, length=3):\n        Receiver approximate position in ECEF coordinates [X, Y, Z] (meters). Used to compute elevation/azimuth and atmospheric delays.\n\n    Returns:\n    iono_error (ndarray, shape=(n,)):\n        The modeled ionospheric delay per satellite: dion (meters).\n\n    trop_error (ndarray, shape=(n,)):\n        The modeled tropospheric delay per satellite: dtrp (meters).\n\n    var_el (ndarray, shape=(n,)):\n        Elevation-dependent variance (empirical model, e.g., for multipath suppression in urban canyons). Computed via RTKLIBvar(azel[1], sys).\n\n    var_iono (ndarray, shape=(n,)):\n        Broadcast ionospheric model variance (squared standard deviation, m\u00b2), output from ionocorr.\n\n    var_tropo (ndarray, shape=(n,)):\n        Saastamoinen tropospheric model variance (m\u00b2), output from tropcorr.\n\n    Processing Steps:\n        Converts receiver ECEF position p to geodetic coordinates (pos) using ecef2pos.\n        For each satellite:\n            Computes line-of-sight vector and satellite elevation/azimuth using geodist and satazel.\n            Calculates ionospheric delay (dion) and its variance (vion) via ionocorr(..., IONOOPT_BRDC, ...).\n            Calculates tropospheric delay (dtrp) and its variance (vtrp) via tropcorr(..., TROPOPT_SAAS, ...).\n            Computes elevation-based variance (vel) using RTKLIBvar(elevation, system) \u2014 useful for downweighting low-elevation satellites.\n        Returns arrays of total atmospheric error and component variances.\n    \"\"\"\n    n = len(satprns)\n    satsys = get_list_sat_name(satprns,True)\n    e = prl.Arr1Ddouble(3)\n    rr = prl.Arr1Ddouble(3)\n    rr[0] = p[0]\n    rr[1] = p[1]\n    rr[2] = p[2]\n    azel = prl.Arr1Ddouble(2)\n    pos = prl.Arr1Ddouble(3)\n    prl.ecef2pos(rr,pos)\n    dion = prl.Arr1Ddouble(1)\n    vion = prl.Arr1Ddouble(1)\n    dtrp = prl.Arr1Ddouble(1)\n    vtrp = prl.Arr1Ddouble(1)\n\n    vels = []\n    vions = []\n    vtrps = []\n    ion_err = []\n    trop_err = []\n    sysname = prl.Arr1Dchar(4)\n\n    for i in range(n):\n        sp = make1Darray(satpos[i],prl.Arr1Ddouble)\n        prl.geodist(sp,rr,e)\n        prl.satazel(pos,e,azel)\n        prl.ionocorr(gtime,nav,satprns[i],pos,azel,prl.IONOOPT_BRDC,dion,vion)\n        prl.tropcorr(gtime,nav,pos,azel,prl.TROPOPT_SAAS,dtrp,vtrp)\n        vel = RTKLIBvar(azel[1],satsys[i])\n        vels.append(vel)\n        vions.append(vion.ptr)\n        vtrps.append(vtrp.ptr)\n        ion_err.append(dion.ptr)\n        trop_err.append(dtrp.ptr)\n    return np.array(ion_err),np.array(trop_err), np.array(vels), np.array(vions),np.array(vtrps)\n</code></pre>"},{"location":"api/#tasgnss.get_obs_pnt","title":"<code>get_obs_pnt(obs, nav, prcopt=None)</code>","text":"<p>Performs Single Point Positioning (SPP) by directly calling RTKLIB\u2019s pntpos() function. Returns the computed position/velocity solution, success/failure status, and diagnostic message.</p> <p>Ideal for quick, standalone positioning without filters or ambiguity resolution.</p> <p>obs (obs_t):     GNSS observation data structure for one epoch (must contain data[0..n-1] of type obsd_t).</p> <p>nav (nav_t):     Navigation data structure with ephemerides, ionospheric/tropospheric models, and satellite biases.</p> <p>prcopt (prcopt_t, optional):     Processing options (e.g., iono/tropo model, elevation mask, positioning mode).     If None, defaults to prl.prcopt_default.</p> <p>sol (sol_t):     Solution structure containing:         sol.rr[0:3]: ECEF position [x, y, z] (meters)         sol.rr[3:6]: ECEF velocity [vx, vy, vz] (m/s) \u2014 if computed         sol.time: Epoch time         Other metadata (refer to RTKLIB documentation for full details).</p> <p>status (bool):     True \u2192 Positioning succeeded (solution is valid)     False \u2192 Positioning failed (check msg for reason)</p> <p>msg (str):     Diagnostic message from RTKLIB. Common failure reasons:         \"insufficient satellites\"         \"gdop error\" (GDOP too high)         \"chi-square error\" (residual validation failed)         \"no navigation data\"</p> Processing Flow <p>Initializes solution and satellite status buffers. Sets solution time to match first observation. Calls RTKLIB\u2019s pntpos() \u2014 computes SPP using pseudoranges, applies models (iono/tropo/dcbs), solves least-squares. Returns raw result \u2014 no post-filtering or smoothing.</p> Source code in <code>tasgnss/core.py</code> <pre><code>def get_obs_pnt(obs, nav, prcopt=None):\n    \"\"\"\n    Performs Single Point Positioning (SPP) by directly calling RTKLIB\u2019s pntpos() function.\n    Returns the computed position/velocity solution, success/failure status, and diagnostic message.\n\n    Ideal for quick, standalone positioning without filters or ambiguity resolution.\n\n    Parameters:\n    obs (obs_t):\n        GNSS observation data structure for one epoch (must contain data[0..n-1] of type obsd_t).\n\n    nav (nav_t):\n        Navigation data structure with ephemerides, ionospheric/tropospheric models, and satellite biases.\n\n    prcopt (prcopt_t, optional):\n        Processing options (e.g., iono/tropo model, elevation mask, positioning mode).\n        If None, defaults to prl.prcopt_default.\n\n    Returns:\n    sol (sol_t):\n        Solution structure containing:\n            sol.rr[0:3]: ECEF position [x, y, z] (meters)\n            sol.rr[3:6]: ECEF velocity [vx, vy, vz] (m/s) \u2014 if computed\n            sol.time: Epoch time\n            Other metadata (refer to RTKLIB documentation for full details).\n\n    status (bool):\n        True \u2192 Positioning succeeded (solution is valid)\n        False \u2192 Positioning failed (check msg for reason)\n\n    msg (str):\n        Diagnostic message from RTKLIB. Common failure reasons:\n            \"insufficient satellites\"\n            \"gdop error\" (GDOP too high)\n            \"chi-square error\" (residual validation failed)\n            \"no navigation data\"\n\n    Processing Flow:\n        Initializes solution and satellite status buffers.\n        Sets solution time to match first observation.\n        Calls RTKLIB\u2019s pntpos() \u2014 computes SPP using pseudoranges, applies models (iono/tropo/dcbs), solves least-squares.\n        Returns raw result \u2014 no post-filtering or smoothing.\n    \"\"\"\n    if prcopt is None:\n        prcopt = prl.prcopt_default\n    m = obs.n\n    sol = prl.sol_t()\n    sat = prl.Arr1Dssat_t(prl.MAXSAT)\n    sol.time = obs.data[0].time\n    msg = prl.Arr1Dchar(100)\n    azel = prl.Arr1Ddouble(m*2)\n    prl.pntpos(obs.data.ptr,obs.n,nav,prcopt,sol,azel,sat.ptr,msg)\n    if msg.ptr and \"chi-square error\" not in msg.ptr and \"gdop error\" not in msg.ptr:\n        return sol,False,msg.ptr\n    else:\n        return sol,True,msg.ptr\n</code></pre>"},{"location":"api/#tasgnss.get_sagnac_corr","title":"<code>get_sagnac_corr(satpos, p)</code>","text":"<p>Computes the Sagnac correction (relativistic range correction due to Earth\u2019s rotation) for GNSS positioning. This effect arises because the Earth rotates during signal propagation, causing a relative motion between satellite and receiver in the ECEF frame. The magnitude is typically ~3 meters and must be corrected for precise positioning.</p> <p>Note: The receiver position p does not need to be highly accurate \u2014 even an error of ~100 meters introduces negligible change in the Sagnac correction.</p> <p>satpos (ndarray, shape=(n, 3) or (n, 6)):     Satellite positions in ECEF coordinates [X, Y, Z] (meters). If 6-element vectors are passed (including velocity), only the first three are used.</p> <p>p (ArrayLike, length=3):     Approximate receiver position in ECEF coordinates [X, Y, Z] (meters). Accuracy requirement: ~100 m is sufficient.</p> <p>sagnac_corr (ndarray, shape=(n,)):     Sagnac correction in meters, one value per satellite.</p> Why It Matters <p>The Sagnac effect is a relativistic correction that accounts for the fact that the ECEF frame is rotating. As the signal travels from satellite to receiver (~0.07s), the Earth rotates slightly, causing a geometric discrepancy if positions are treated as static in ECEF. This correction ensures consistency with the inertial frame assumption in GNSS signal models.</p> Source code in <code>tasgnss/core.py</code> <pre><code>def get_sagnac_corr(satpos, p):\n    \"\"\"\n    Computes the Sagnac correction (relativistic range correction due to Earth\u2019s rotation) for GNSS positioning.\n    This effect arises because the Earth rotates during signal propagation, causing a relative motion between satellite and receiver in the ECEF frame.\n    The magnitude is typically ~3 meters and must be corrected for precise positioning.\n\n    Note: The receiver position p does not need to be highly accurate \u2014 even an error of ~100 meters introduces negligible change in the Sagnac correction.\n\n    Parameters:\n    satpos (ndarray, shape=(n, 3) or (n, 6)):\n        Satellite positions in ECEF coordinates [X, Y, Z] (meters). If 6-element vectors are passed (including velocity), only the first three are used.\n\n    p (ArrayLike, length=3):\n        Approximate receiver position in ECEF coordinates [X, Y, Z] (meters). Accuracy requirement: ~100 m is sufficient.\n\n    Returns:\n    sagnac_corr (ndarray, shape=(n,)):\n        Sagnac correction in meters, one value per satellite.\n\n    Why It Matters:\n        The Sagnac effect is a relativistic correction that accounts for the fact that the ECEF frame is rotating.\n        As the signal travels from satellite to receiver (~0.07s), the Earth rotates slightly, causing a geometric discrepancy if positions are treated as static in ECEF.\n        This correction ensures consistency with the inertial frame assumption in GNSS signal models.\n    \"\"\"\n    sagnac_corr = prl.OMGE*(satpos[:,0]*p[1]-satpos[:,1]*p[0])/prl.CLIGHT\n    return sagnac_corr\n</code></pre>"},{"location":"api/#tasgnss.get_sat_pos","title":"<code>get_sat_pos(obsd, n, nav)</code>","text":"<p>Computes satellite positions, velocities, clock biases, and associated ephemeris variances for a given epoch of observations. Filters out satellites with invalid or missing ephemeris data and returns only valid entries.</p> <p>Note: The input is obsd_t (i.e., obs.data), not obs_t. Typical usage: get_sat_pos(obs.data, obs.n, nav)</p> <p>obsd (Arr1Dobsd_t or equivalent):     Array of observation data for one epoch (e.g., obs.data). Must be contiguous and correspond to n satellites.</p> <p>n (int):     Number of satellites (i.e., number of elements in obsd) for this epoch.</p> <p>nav (nav_t):     Ephemeris and clock data structure, typically populated by read_obs() or equivalent.</p> <p>rr (Arr1Ddouble, length = 6 * len(mask)):     Satellite positions and velocities, packed as [x, y, z, vx, vy, vz] for each valid satellite. Units: meters and meters/second.</p> <p>dts (Arr1Ddouble, length = 2 * len(mask)):     Satellite clock bias and drift, packed as [bias, drift] for each valid satellite. Units: seconds and seconds/second.</p> <p>var (Arr1Ddouble, length = len(mask)):     Ephemeris variance (squared standard deviation) for each valid satellite. Unit: m\u00b2.</p> <p>mask (List[int]):     List of indices (from original 0..n-1) corresponding to satellites with valid ephemeris data. Used to map back to original observation order.</p> <p>Processing Details: Internally calls RTKLIB\u2019s satposs() to compute satellite states. Identifies satellites with invalid position data (where |x| &lt; 1e-10) as \u201cno ephemeris\u201d. Constructs a mask of valid satellite indices. Uses helper function arr_select to filter rs, dts, and var arrays according to the mask. Returns filtered arrays and mask.</p> Source code in <code>tasgnss/core.py</code> <pre><code>def get_sat_pos(obsd, n, nav):\n    \"\"\"\n    Computes satellite positions, velocities, clock biases, and associated ephemeris variances for a given epoch of observations.\n    Filters out satellites with invalid or missing ephemeris data and returns only valid entries.\n\n    Note: The input is obsd_t (i.e., obs.data), not obs_t.\n    Typical usage: get_sat_pos(obs.data, obs.n, nav)\n\n    Parameters:\n    obsd (Arr1Dobsd_t or equivalent):\n        Array of observation data for one epoch (e.g., obs.data). Must be contiguous and correspond to n satellites.\n\n    n (int):\n        Number of satellites (i.e., number of elements in obsd) for this epoch.\n\n    nav (nav_t):\n        Ephemeris and clock data structure, typically populated by read_obs() or equivalent.\n\n    Returns:\n    rr (Arr1Ddouble, length = 6 * len(mask)):\n        Satellite positions and velocities, packed as [x, y, z, vx, vy, vz] for each valid satellite. Units: meters and meters/second.\n\n    dts (Arr1Ddouble, length = 2 * len(mask)):\n        Satellite clock bias and drift, packed as [bias, drift] for each valid satellite. Units: seconds and seconds/second.\n\n    var (Arr1Ddouble, length = len(mask)):\n        Ephemeris variance (squared standard deviation) for each valid satellite. Unit: m\u00b2.\n\n    mask (List[int]):\n        List of indices (from original 0..n-1) corresponding to satellites with valid ephemeris data. Used to map back to original observation order.\n\n    Processing Details:\n    Internally calls RTKLIB\u2019s satposs() to compute satellite states.\n    Identifies satellites with invalid position data (where |x| &lt; 1e-10) as \u201cno ephemeris\u201d.\n    Constructs a mask of valid satellite indices.\n    Uses helper function arr_select to filter rs, dts, and var arrays according to the mask.\n    Returns filtered arrays and mask.\n    \"\"\"\n    svh = prl.Arr1Dint(prl.MAXOBS)\n    rs = prl.Arr1Ddouble(6*n)\n    dts = prl.Arr1Ddouble(2*n)\n    var = prl.Arr1Ddouble(1*n)\n    prl.satposs(obsd[0].time,obsd.ptr,n,nav,0,rs,dts,var,svh)\n    noeph = []\n    for i in range(n):\n        if abs(rs[6*i]) &lt; 1e-10:\n            noeph.append(i)\n    mask = list(set(range(n))-set(noeph))\n    nrs = arr_select(rs,mask,6)\n    var = arr_select(var,mask)\n    ndts = arr_select(dts,mask,2)\n    nrs = np.array(nrs).reshape(-1,6)\n    ndts = np.array(ndts).reshape(-1,2)\n    var = np.array(var)\n    return nrs,ndts,var,mask\n</code></pre>"},{"location":"api/#tasgnss.prange","title":"<code>prange(obs, nav, opt, var)</code>","text":"<p>Computes the corrected pseudorange for a single satellite observation, applying differential code bias (DCB) and ionospheric delay corrections based on configuration. Supports both single-frequency and ionosphere-free dual-frequency combinations.</p> <p>obs (obsd_t):     Single satellite observation record from an epoch (e.g., obs.data[i]). Must contain pseudorange measurements (P[0], P[1]) and signal codes (code[0], code[1]).</p> <p>nav (nav_t):     Ephemeris and satellite bias structure containing DCB (differential code bias) and TGD (time group delay) corrections.</p> <p>opt (prcopt_t or equivalent):     Processing options structure. Key field:     opt.ionoopt: Specifies ionospheric correction mode (e.g., IONOOPT_IFLC for ionosphere-free linear combination).</p> <p>var (Arr1Ddouble, length \u2265 1):     Output array \u2014 var[0] is set to the default code variance (0.3\u00b2 m\u00b2) for single-frequency cases. Not modified in dual-frequency mode.</p> <p>p (float):     Corrected pseudorange in meters. Returns 0.0 if:     P1 is missing, or     Dual-frequency mode is enabled but P2 is missing.</p> <p>Processing Logic: DCB Correction (C1\u2192P1, C2\u2192P2):     Applied for GPS and GLONASS if code type indicates C/A code (CODE_L1C or CODE_L2C). Uses satellite-specific biases from nav.cbias.</p> <p>Ionosphere-Free Combination (if opt.ionoopt == IONOOPT_IFLC):     Uses dual-frequency pseudoranges (P1, P2) to form ionosphere-free linear combination:     p = (P2 - \u03b3\u00b7P1) / (1 - \u03b3)     where \u03b3 = (f1/f2)\u00b2 (frequency ratio squared).</p> <pre><code>For BeiDou and Galileo, additional TGD/BDG corrections are applied before combination.\nSystem-specific frequency constants and bias models are used (GPS, GLO, GAL, CMP, IRN).\n</code></pre> <p>Single-Frequency Mode (default):     Applies only TGD or BGD correction to P1. Sets var[0] = 0.3\u00b2 (default code variance).     System-specific TGD models applied (e.g., GPS TGD, GLO \u2013dtaun, GAL BGD, etc.).</p> Supported GNSS <p>GPS / QZSS: L1-L2 (IFLC) or L1-only GLONASS: G1-G2 (IFLC) or G1-only Galileo: E1-E5b (IFLC) or E1-only (BGD applied) BeiDou: B1-B2 (IFLC) or B1I/B1Cp/B1Cd (TGD/ISC applied) NavIC (IRNSS): L5-S (IFLC) or L5-only</p> Source code in <code>tasgnss/core.py</code> <pre><code>def prange(obs, nav, opt, var):\n    \"\"\"\n    Computes the corrected pseudorange for a single satellite observation, applying differential code bias (DCB) and ionospheric delay corrections based on configuration.\n    Supports both single-frequency and ionosphere-free dual-frequency combinations.\n\n    Parameters:\n    obs (obsd_t):\n        Single satellite observation record from an epoch (e.g., obs.data[i]). Must contain pseudorange measurements (P[0], P[1]) and signal codes (code[0], code[1]).\n\n    nav (nav_t):\n        Ephemeris and satellite bias structure containing DCB (differential code bias) and TGD (time group delay) corrections.\n\n    opt (prcopt_t or equivalent):\n        Processing options structure. Key field:\n        opt.ionoopt: Specifies ionospheric correction mode (e.g., IONOOPT_IFLC for ionosphere-free linear combination).\n\n    var (Arr1Ddouble, length \u2265 1):\n        Output array \u2014 var[0] is set to the default code variance (0.3\u00b2 m\u00b2) for single-frequency cases. Not modified in dual-frequency mode.\n\n    Returns:\n    p (float):\n        Corrected pseudorange in meters. Returns 0.0 if:\n        P1 is missing, or\n        Dual-frequency mode is enabled but P2 is missing.\n\n    Processing Logic:\n    DCB Correction (C1\u2192P1, C2\u2192P2):\n        Applied for GPS and GLONASS if code type indicates C/A code (CODE_L1C or CODE_L2C). Uses satellite-specific biases from nav.cbias.\n\n    Ionosphere-Free Combination (if opt.ionoopt == IONOOPT_IFLC):\n        Uses dual-frequency pseudoranges (P1, P2) to form ionosphere-free linear combination:\n        p = (P2 - \u03b3\u00b7P1) / (1 - \u03b3)\n        where \u03b3 = (f1/f2)\u00b2 (frequency ratio squared).\n\n        For BeiDou and Galileo, additional TGD/BDG corrections are applied before combination.\n        System-specific frequency constants and bias models are used (GPS, GLO, GAL, CMP, IRN).\n\n    Single-Frequency Mode (default):\n        Applies only TGD or BGD correction to P1. Sets var[0] = 0.3\u00b2 (default code variance).\n        System-specific TGD models applied (e.g., GPS TGD, GLO \u2013dtaun, GAL BGD, etc.).\n\n    Supported GNSS:\n        GPS / QZSS: L1-L2 (IFLC) or L1-only\n        GLONASS: G1-G2 (IFLC) or G1-only\n        Galileo: E1-E5b (IFLC) or E1-only (BGD applied)\n        BeiDou: B1-B2 (IFLC) or B1I/B1Cp/B1Cd (TGD/ISC applied)\n        NavIC (IRNSS): L5-S (IFLC) or L5-only\n    \"\"\"\n    P1, P2, gamma, b1, b2 = 0.0, 0.0, 0.0, 0.0, 0.0\n    var[0] = 0.0\n\n    sat = obs.sat\n\n    sys_name = prl.Arr1Dchar(4)\n    prl.satno2id(sat,sys_name)\n    sys = SYS[sys_name.ptr[0]]\n    P1 = obs.P[0]\n    P2 = obs.P[1]\n\n    if P1 == 0.0 or (opt.ionoopt == prl.IONOOPT_IFLC and P2 == 0.0):\n        return 0.0\n\n    # P1-C1, P2-C2 DCB correction\n    if sys == prl.SYS_GPS or sys == prl.SYS_GLO:\n        if obs.code[0] == prl.CODE_L1C:\n            P1 += nav.cbias[sat - 1,1]  # C1-&gt;P1\n        if obs.code[1] == prl.CODE_L2C:\n            P2 += nav.cbias[sat - 1,2]  # C2-&gt;P2\n\n    if opt.ionoopt == prl.IONOOPT_IFLC:  # dual-frequency\n        if sys == prl.SYS_GPS or sys == prl.SYS_QZS:  # L1-L2, G1-G2\n            gamma = (prl.FREQ1 / prl.FREQ2) ** 2\n            return (P2 - gamma * P1) / (1.0 - gamma)\n        elif sys == prl.SYS_GLO:  # G1-G2\n            gamma = (prl.FREQ1_GLO / prl.FREQ2_GLO) ** 2\n            return (P2 - gamma * P1) / (1.0 - gamma)\n        elif sys == prl.SYS_GAL:  # E1-E5b\n            gamma = (prl.FREQ1 / prl.FREQ7) ** 2\n            if prl.getseleph(prl.SYS_GAL):  # F/NAV\n                P2 -= gettgd(sat, nav, 0) - gettgd(sat, nav, 1)  # BGD_E5aE5b\n            return (P2 - gamma * P1) / (1.0 - gamma)\n        elif sys == prl.SYS_CMP:  # B1-B2\n            gamma = (((prl.FREQ1_CMP if obs.code[0] == prl.CODE_L2I else prl.FREQ1) / prl.FREQ2_CMP) ** 2)\n            b1 = gettgd(sat, nav, 0) if obs.code[0] == prl.CODE_L2I else gettgd(sat, nav, 2) if obs.code[0] == prl.CODE_L1P else gettgd(sat, nav, 2) + gettgd(sat, nav, 4)  # TGD_B1I / TGD_B1Cp / TGD_B1Cp+ISC_B1Cd\n            b2 = gettgd(sat, nav, 1)  # TGD_B2I/B2bI (m)\n            return ((P2 - gamma * P1) - (b2 - gamma * b1)) / (1.0 - gamma)\n        elif sys == prl.SYS_IRN:  # L5-S\n            gamma = (prl.FREQ5 / prl.FREQ9) ** 2\n            return (P2 - gamma * P1) / (1.0 - gamma)\n    else:  # single-freq (L1/E1/B1)\n        var[0] = 0.3 ** 2\n\n        if sys == prl.SYS_GPS or sys == prl.SYS_QZS:  # L1\n            b1 = gettgd(sat, nav, 0)  # TGD (m)\n            return P1 - b1\n        elif sys == prl.SYS_GLO:  # G1\n            gamma = (prl.FREQ1_GLO / prl.FREQ2_GLO) ** 2\n            b1 = gettgd(sat, nav, 0)  # -dtaun (m)\n            return P1 - b1 / (gamma - 1.0)\n        elif sys == prl.SYS_GAL:  # E1\n            b1 = gettgd(sat, nav, 0) if prl.getseleph(prl.SYS_GAL) else gettgd(sat, nav, 1)  # BGD_E1E5a / BGD_E1E5b\n            return P1 - b1\n        elif sys == prl.SYS_CMP:  # B1I/B1Cp/B1Cd\n            b1 = gettgd(sat, nav, 0) if obs.code[0] == prl.CODE_L2I else gettgd(sat, nav, 2) if obs.code[0] == prl.CODE_L1P else gettgd(sat, nav, 2) + gettgd(sat, nav, 4)  # TGD_B1I / TGD_B1Cp / TGD_B1Cp+ISC_B1Cd\n            return P1 - b1\n        elif sys == prl.SYS_IRN:  # L5\n            gamma = (prl.FREQ9 / prl.FREQ5) ** 2\n            b1 = gettgd(sat, nav, 0)  # TGD (m)\n            return P1 - gamma * b1\n    return P1\n</code></pre>"},{"location":"api/#tasgnss.preprocess_obs","title":"<code>preprocess_obs(o, nav, use_cache=True)</code>","text":"<p>Preprocesses GNSS observation data for positioning.</p> <p>Parameters: o (obs_t): GNSS observation data structure for one epoch. nav (nav_t): Navigation data structure with ephemerides and satellite biases. use_cache (bool, optional): Whether to use cached results if available.</p> <p>Returns: dict: A dictionary containing preprocessing results and status information.</p> Source code in <code>tasgnss/core.py</code> <pre><code>def preprocess_obs(o, nav, use_cache=True):\n    \"\"\"\n    Preprocesses GNSS observation data for positioning.\n\n    Parameters:\n    o (obs_t): GNSS observation data structure for one epoch.\n    nav (nav_t): Navigation data structure with ephemerides and satellite biases.\n    use_cache (bool, optional): Whether to use cached results if available.\n\n    Returns:\n    dict: A dictionary containing preprocessing results and status information.\n    \"\"\"\n    o_id = id(o)\n    if o.n &lt; 4:\n            return [[None] * 7][0]\n    # intialize with pntpos can help fix some position-related parameters, such as sagnac, ionosphere, troposphere, or it need a iteration to solve it.\n    sol, status, msg = get_obs_pnt(o,nav)\n    # if not status:\n    #     return [[None] * 7][0]\n    p = np.array([sol.rr[0],sol.rr[1],sol.rr[2]])\n    time = o.data[0].time\n    satpos,sdt,var,mask = get_sat_pos(o.data,o.n,nav)\n    opt = prl.prcopt_default\n    vmeas = prl.Arr1Ddouble(1)\n    o.data = arr_select(o.data,mask)\n    o.n = len(mask)\n    o.nmax = o.n\n    data = []\n    sagnac = get_sagnac_corr(satpos[:,:3], p)\n    iono_error, trop_error, var_els, var_ions, var_tropos = get_atmosphere_error(time,satpos[:,:3], [o.data[i].sat for i in range(o.n)], nav, p)\n    satpos_enu = ecef_to_enu_direct(satpos[:,:3],p)\n    az,el = enu_to_azel(satpos_enu)\n    for i in range(o.n):\n        obsd = o.data[i]\n        # store raw data\n        raw_data = {}\n        raw_data['P'] = np.array(obsd.P[0:3])\n        raw_data['L'] = np.array(obsd.L[0:3])\n        raw_data['D'] = np.array(obsd.D[0:3])\n        raw_data['SNR'] = np.array(obsd.SNR[0:3])/1000\n        raw_data['LLI'] = np.array(obsd.LLI[0:3])\n        raw_data['code'] = np.array(obsd.code[0:3])\n\n        sname = get_sat_name(obsd.sat)\n        s_sys = sname[0]\n\n        corrected_p = prange(obsd,nav,opt,vmeas)\n        dop = obsd.D[0]\n        if corrected_p == 0.0:\n            continue\n\n        freq = prl.sat2freq(obsd.sat,obsd.code[0],nav)\n\n        data.append(\n            (\n                obsd.sat,\n                sname,\n                s_sys,\n                satpos[i],\n                sdt[i],\n                corrected_p,\n                sagnac[i],\n                iono_error[i],\n                trop_error[i],\n                obsd.SNR[0]/1000,\n                var[i]+vmeas.ptr+var_els[i]+var_ions[i]+var_tropos[i],\n                az[i],\n                el[i],\n                -prl.CLIGHT/freq*dop,\n                freq\n            )\n        )\n    data = np.array(data,dtype=object)\n    cdata = {\n        'satpos': np.array(data[:,3].tolist()).astype(np.float64),\n        'pr': data[:,5].astype(np.float64).reshape(-1,1),\n        'dop': data[:,13].astype(np.float64).reshape(-1,1),\n        'sdt': np.vstack(data[:,4]).astype(np.float64),\n        'sagnac': data[:,6].astype(np.float64),\n        'I': data[:,7].astype(np.float64),\n        'T': data[:,8].astype(np.float64),\n        'sys': data[:,2].tolist(),\n        'var': data[:,10].astype(np.float64),\n    }\n    p = None\n    p_t = None\n    ret_data = [None,None,None,None,data,cdata,raw_data]\n    # if it's initialization, do not store the position and receiver clock bias\n    if use_cache:\n        cache_data[o_id] = ret_data\n    return ret_data\n</code></pre>"},{"location":"api/#tasgnss.pseudorange_observe_func","title":"<code>pseudorange_observe_func(pos, dt, satpos, sdt, I, T, sagnac, sys, keep_states=True, enable_torch=False, device='cpu')</code>","text":"<p>Computes pseudorange observation residuals and their Jacobian matrix for GNSS positioning. Models geometric range, Sagnac effect, receiver-satellite clock bias difference, and optional iono/tropo delays. The state vector assumed is: [x, y, z, dt_sys1, dt_sys2, ...] \u2014 position + per-system clock bias (no velocity or clock drift). Clock drift is handled externally (e.g., in Doppler module), enabling modular design via block_diag fusion.</p> <p>Parameters: pos : receiver position (ECEF), shape (3,) dt : receiver clock bias per GNSS system, shape (n_sys,), unit: m     \u2192 e.g., dt = [dt_GPS, dt_GAL, dt_BDS, ...] satpos : satellite positions (ECEF), shape (n_obs, 3) sdt : satellite clock biases (from broadcast/SP3), shape (n_obs,), unit: s I : ionospheric delay (optional, can be zero), shape (n_obs, 1), unit: m T : tropospheric delay (optional, can be zero), shape (n_obs, 1), unit: m sagnac : precomputed Sagnac correction term (from get_sagnac_corr), shape (n_obs, 1), unit: m sys : list of GNSS system identifiers for each observation, e.g., ['G', 'E', 'C'] keep_states : if False, removes Jacobian columns corresponding to systems with no observation (for WLS compatibility) enable_torch : if True, use PyTorch backend for computations device : if enable_torch is True, specifies the device ('cpu' or 'cuda')</p> <p>Returns: psr : predicted pseudorange residuals (m), shape (n_obs, 1) H : Jacobian matrix w.r.t state [x, y, z, dt_sys1, dt_sys2, ...], shape (n_obs, 3 + n_active_sys)</p> Source code in <code>tasgnss/core.py</code> <pre><code>def pseudorange_observe_func(pos, dt, satpos, sdt, I, T, sagnac, sys, keep_states=True, enable_torch=False, device='cpu'):\n    \"\"\"\n    Computes pseudorange observation residuals and their Jacobian matrix for GNSS positioning.\n    Models geometric range, Sagnac effect, receiver-satellite clock bias difference, and optional iono/tropo delays.\n    The state vector assumed is: [x, y, z, dt_sys1, dt_sys2, ...] \u2014 position + per-system clock bias (no velocity or clock drift).\n    Clock drift is handled externally (e.g., in Doppler module), enabling modular design via block_diag fusion.\n\n    Parameters:\n    pos : receiver position (ECEF), shape (3,)\n    dt : receiver clock bias per GNSS system, shape (n_sys,), unit: m\n        \u2192 e.g., dt = [dt_GPS, dt_GAL, dt_BDS, ...]\n    satpos : satellite positions (ECEF), shape (n_obs, 3)\n    sdt : satellite clock biases (from broadcast/SP3), shape (n_obs,), unit: s\n    I : ionospheric delay (optional, can be zero), shape (n_obs, 1), unit: m\n    T : tropospheric delay (optional, can be zero), shape (n_obs, 1), unit: m\n    sagnac : precomputed Sagnac correction term (from get_sagnac_corr), shape (n_obs, 1), unit: m\n    sys : list of GNSS system identifiers for each observation, e.g., ['G', 'E', 'C']\n    keep_states : if False, removes Jacobian columns corresponding to systems with no observation (for WLS compatibility)\n    enable_torch : if True, use PyTorch backend for computations\n    device : if enable_torch is True, specifies the device ('cpu' or 'cuda')\n\n    Returns:\n    psr : predicted pseudorange residuals (m), shape (n_obs, 1)\n    H : Jacobian matrix w.r.t state [x, y, z, dt_sys1, dt_sys2, ...], shape (n_obs, 3 + n_active_sys)\n    \"\"\"\n    backend = Backend(enable_torch)\n\n    satpos = backend.asarray(satpos, dtype=backend.float64)\n    sdt = backend.asarray(sdt, dtype=backend.float64)\n    I = backend.asarray(I, dtype=backend.float64)\n    T = backend.asarray(T, dtype=backend.float64)\n    sagnac = backend.asarray(sagnac, dtype=backend.float64)\n\n    pos = backend.to(pos, device)\n    dt = backend.to(dt, device)\n    satpos = backend.to(satpos, device)\n    sdt = backend.to(sdt, device)\n    I = backend.to(I, device)\n    T = backend.to(T, device)\n    sagnac = backend.to(sagnac, device)\n\n    #dt = dt/prl.CLIGHT # convert m to s\n\n    # \u51e0\u4f55\u8ddd\u79bb + \u5355\u4f4d\u5411\u91cf\n    diff = satpos - pos  # shape: (n_obs, 3)\n    norm = backend.linalg_norm(diff, axis=1).reshape(-1, 1)  # shape: (n_obs, 1)\n    e = -diff / norm  # shape: (n_obs, 3)\n\n    psr1 = norm + sagnac.reshape(-1, 1)  # shape: (n_obs, 1)\n    psr2 = dt - prl.CLIGHT * sdt       # shape: (n_obs,)\n    psr3 = I + T                         # shape: (n_obs, 1)\n\n    psr = psr1 + psr2.reshape(-1, 1) + psr3.reshape(-1, 1)  # shape: (n_obs, 1)\n\n    # \u6784\u9020\u949f\u5dee\u6620\u5c04\u77e9\u9635 H_t: (n_obs, n_sys)\n    idx = backend.array([list(SYS_NAME).index(s) for s in sys], dtype=backend.int64)\n    eye_matrix = backend.eye(len(SYS_NAME), dtype=backend.float64)\n    H_t = eye_matrix[idx]  # shape: (n_obs, n_sys)\n\n    # \u53ef\u9009\uff1a\u79fb\u9664\u65e0\u89c2\u6d4b\u7cfb\u7edf\u7684\u5217\n    if not keep_states:\n        non_zero_cols = backend.any(H_t != 0, axis=0)  # shape: (n_sys,)\n        H_t = H_t[:, non_zero_cols]  # shape: (n_obs, n_active_sys)\n\n    H_t = backend.to(H_t, device)\n\n    # \u6784\u9020\u5b8c\u6574 Jacobian: [\u2202psr/\u2202x, \u2202psr/\u2202y, \u2202psr/\u2202z, \u2202psr/\u2202dt1, \u2202psr/\u2202dt2, ...]\n    H_pos = e  # shape: (n_obs, 3)\n    H_clock = H_t  # shape: (n_obs, n_sys) or (n_obs, n_active_sys)\n    H = backend.hstack((H_pos, H_clock))  # shape: (n_obs, 3 + n_sys)\n\n    return psr, H\n</code></pre>"},{"location":"api/#tasgnss.read_obs","title":"<code>read_obs(rcv, eph, ref=None)</code>","text":"<p>Reads GNSS observation and ephemeris data from RINEX files using RTKLIB\u2019s internal structures.</p> <p>rcv (str or list of str):     Path(s) to RINEX observation file(s) containing receiver measurements.     These files are read as observation data (type 1 in RTKLIB).</p> <p>eph (str or list of str):     Path(s) to RINEX navigation/ephemeris file(s).     These files are read as ephemeris data (type 2 in RTKLIB).</p> <p>ref (str or list of str, optional):     Path(s) to RINEX observation file(s) from a reference station, used for Real-Time Kinematic (RTK) processing.     If provided, these are also read as type 2 (ephemeris-type) data for reference station handling.</p> <p>Returns: obs_t: RTKLIB structure containing GNSS observation data (pseudorange, carrier phase, etc.). nav_t: RTKLIB structure containing satellite ephemeris, clock, and ionospheric model data. sta_t: RTKLIB structure containing station information (e.g., antenna position, receiver info), primarily populated when reading reference station files.</p> Source code in <code>tasgnss/core.py</code> <pre><code>def read_obs(rcv, eph, ref=None):\n    \"\"\"\n    Reads GNSS observation and ephemeris data from RINEX files using RTKLIB\u2019s internal structures.\n\n    Parameters:\n    rcv (str or list of str):\n        Path(s) to RINEX observation file(s) containing receiver measurements.\n        These files are read as observation data (type 1 in RTKLIB).\n\n    eph (str or list of str):\n        Path(s) to RINEX navigation/ephemeris file(s).\n        These files are read as ephemeris data (type 2 in RTKLIB).\n\n    ref (str or list of str, optional):\n        Path(s) to RINEX observation file(s) from a reference station, used for Real-Time Kinematic (RTK) processing.\n        If provided, these are also read as type 2 (ephemeris-type) data for reference station handling.\n\n    Returns:\n    obs_t: RTKLIB structure containing GNSS observation data (pseudorange, carrier phase, etc.).\n    nav_t: RTKLIB structure containing satellite ephemeris, clock, and ionospheric model data.\n    sta_t: RTKLIB structure containing station information (e.g., antenna position, receiver info), primarily populated when reading reference station files.\n    \"\"\"\n    obs = prl.obs_t()\n    nav = prl.nav_t()\n    sta = prl.sta_t()\n    if type(rcv) is list:\n        for r in rcv:\n            prl.readrnx(r,1,\"\",obs,nav,sta)\n    else:\n        prl.readrnx(rcv,1,\"\",obs,nav,sta)\n    if type(eph) is list:\n        for f in eph:\n            prl.readrnx(f,2,\"\",obs,nav,sta)\n    else:\n        prl.readrnx(eph,2,\"\",obs,nav,sta)\n    if ref:\n        if type(ref) is list:\n            for r in ref:\n                prl.readrnx(r,2,\"\",obs,nav,sta)\n        else:\n            prl.readrnx(ref,2,\"\",obs,nav,sta)\n    return obs,nav,sta\n</code></pre>"},{"location":"api/#tasgnss.split_obs","title":"<code>split_obs(obs, ref_obs=False)</code>","text":"<p>Splits a monolithic obs_t structure into a list of obs_t objects, each containing observations from a single epoch. This facilitates per-epoch processing in applications such as RTK or time-series analysis.</p> <p>obs (obs_t):     The input observation structure, typically generated by read_obs(). All observations across all epochs are stored in obs.data.</p> <p>ref_obs (bool, optional, default=True):     If True, includes reference station observations (receiver ID = 2) in the split epoch data.     If False, only observations from the primary receiver (receiver ID = 1) are retained per epoch.</p> <p>List[obs_t]:     A list of obs_t structures, each representing one epoch\u2019s worth of observation data. Each element contains:     .data: Array of observations for that epoch.     .n: Actual number of observations in the epoch.     .nmax: Maximum allocated size (equal to total observations detected for the epoch).</p> <p>Behavior: First calls pyrtklib.sortobs(obs) to ensure observations are sorted chronologically by time and receiver. Iterates through epochs using nextobsf(obs, i) to locate epoch boundaries. For each epoch:     Allocates a new obs_t structure.     Copies observations from receiver 1 (primary).     If ref_obs=True, also copies observations from receiver 2 (reference station), appending them after receiver 1\u2019s data.     Skips epochs with no primary receiver data. Returns the list of per-epoch obs_t structures.</p> Source code in <code>tasgnss/core.py</code> <pre><code>def split_obs(obs, ref_obs=False):\n    \"\"\"\n    Splits a monolithic obs_t structure into a list of obs_t objects, each containing observations from a single epoch.\n    This facilitates per-epoch processing in applications such as RTK or time-series analysis.\n\n    Parameters:\n    obs (obs_t):\n        The input observation structure, typically generated by read_obs(). All observations across all epochs are stored in obs.data.\n\n    ref_obs (bool, optional, default=True):\n        If True, includes reference station observations (receiver ID = 2) in the split epoch data.\n        If False, only observations from the primary receiver (receiver ID = 1) are retained per epoch.\n\n    Returns:\n    List[obs_t]:\n        A list of obs_t structures, each representing one epoch\u2019s worth of observation data. Each element contains:\n        .data: Array of observations for that epoch.\n        .n: Actual number of observations in the epoch.\n        .nmax: Maximum allocated size (equal to total observations detected for the epoch).\n\n    Behavior:\n    First calls pyrtklib.sortobs(obs) to ensure observations are sorted chronologically by time and receiver.\n    Iterates through epochs using nextobsf(obs, i) to locate epoch boundaries.\n    For each epoch:\n        Allocates a new obs_t structure.\n        Copies observations from receiver 1 (primary).\n        If ref_obs=True, also copies observations from receiver 2 (reference station), appending them after receiver 1\u2019s data.\n        Skips epochs with no primary receiver data.\n    Returns the list of per-epoch obs_t structures.\n    \"\"\"\n    prl.sortobs(obs)\n    i = 0\n    m = nextobsf(obs,i)\n    obss = []\n    while m!=0:\n        tmp_obs = prl.obs_t()\n        tmp_obs.data = prl.Arr1Dobsd_t(m)\n        rcv1 = 0\n        rcv2 = 0\n        for j in range(m):\n            if obs.data[i+j].rcv == 1:\n                tmp_obs.data[rcv1] = obs.data[i+j]\n                rcv1+=1\n        if rcv1 == 0:\n            i+=m\n            m = nextobsf(obs,i)\n            continue\n        if rcv1 != m and ref_obs:\n            for j in range(m-rcv1):\n                if obs.data[i+j+rcv1].rcv == 2:\n                    tmp_obs.data[rcv1+rcv2] = obs.data[i+rcv1+j]\n                    rcv2+=1\n        tmp_obs.n = rcv1+rcv2\n        tmp_obs.nmax = m\n        i+=m\n        obss.append(tmp_obs)\n        m = nextobsf(obs,i)\n    return obss\n</code></pre>"},{"location":"api/#tasgnss.wls_pnt_pos","title":"<code>wls_pnt_pos(o, nav, use_cache=True, return_residual=False, enable_torch=False, w=None, b=None, device='cpu')</code>","text":"<p>Performs Weighted Least Squares (WLS) positioning using GNSS observations.</p> <p>This function implements an iterative WLS algorithm to solve for receiver position, velocity, and clock parameters. It supports caching for performance optimization and PyTorch backend for gradient-based optimization.</p> <p>Key Features: - Uses caching to accelerate repeated calls with the same observation data - Supports PyTorch backend for gradient propagation, enabling use in neural network optimization - Handles multiple GNSS constellations with separate clock bias parameters - Includes atmospheric and relativistic corrections</p> <p>o (obs_t):      GNSS observation data structure for one epoch. nav (nav_t):      Navigation data structure with ephemerides and satellite biases. use_cache (bool, optional):      Whether to use cached preprocessing results. When True, if the same     observation object is processed multiple times, the preprocessing results (satellite positions,     atmospheric corrections, etc.) are cached and reused, significantly speeding up repeated calls.     Default is True. return_residual (bool, optional):      Whether to return residuals, Jacobian matrix, and weight matrix.     When True, the returned dictionary includes a \"residual_info\" key containing:     - \"residual\": Observation residuals vector     - \"H\": Design matrix (Jacobian)     - \"W\": Weight matrix     These can be used to compute Dilution of Precision (DOP) metrics. Default is False. enable_torch (bool, optional):      Whether to use PyTorch backend for computations. When True,     the function uses PyTorch tensors and operations, allowing gradients to flow through the     computation graph. This enables the use of this function in neural network training, where     weights (w) and bias (b) can be optimized using gradient descent. Default is False. w (array-like, optional): Weight matrix for pseudorange observations. If enable_torch=True,     gradients will propagate through w to the position solution, allowing wp to be optimized     in neural networks. Default is None (uses inverse of observation variance). b (array-like, optional): Bias vector to be subtracted from pseudorange observations. If     enable_torch=True, gradients will propagate through b to the position solution, allowing     b to be optimized in neural networks. Default is None (zero vector). device (str, optional): Device to run PyTorch computations on ('cpu' or 'cuda'). Default is 'cpu'.</p> <p>dict: A dictionary containing positioning results, status, and additional information with keys:     - \"status\" (bool): True if positioning succeeded, False otherwise     - \"pos\" (array): Receiver position [x, y, z] in ECEF coordinates     - \"cb\" (array): Receiver clock bias for each GNSS system     - \"cd\" (array): Receiver clock drift     - \"msg\" (str): Status message     - \"data\" (array): Processed observation data     - \"solve_data\" (dict): Preprocessed data used in solving     - \"raw_data\" (dict): Raw observation data     - \"residual_info\" (dict, optional): Residuals and Jacobian matrix if return_residual=True</p> Source code in <code>tasgnss/core.py</code> <pre><code>def wls_pnt_pos(o, nav, use_cache=True, return_residual=False, enable_torch=False, w=None, b=None, device='cpu'):\n    \"\"\"\n    Performs Weighted Least Squares (WLS) positioning using GNSS observations.\n\n    This function implements an iterative WLS algorithm to solve for receiver position, velocity,\n    and clock parameters. It supports caching for performance optimization and PyTorch backend\n    for gradient-based optimization.\n\n    Key Features:\n    - Uses caching to accelerate repeated calls with the same observation data\n    - Supports PyTorch backend for gradient propagation, enabling use in neural network optimization\n    - Handles multiple GNSS constellations with separate clock bias parameters\n    - Includes atmospheric and relativistic corrections\n\n    Parameters:\n    o (obs_t): \n        GNSS observation data structure for one epoch.\n    nav (nav_t): \n        Navigation data structure with ephemerides and satellite biases.\n    use_cache (bool, optional): \n        Whether to use cached preprocessing results. When True, if the same\n        observation object is processed multiple times, the preprocessing results (satellite positions,\n        atmospheric corrections, etc.) are cached and reused, significantly speeding up repeated calls.\n        Default is True.\n    return_residual (bool, optional): \n        Whether to return residuals, Jacobian matrix, and weight matrix.\n        When True, the returned dictionary includes a \"residual_info\" key containing:\n        - \"residual\": Observation residuals vector\n        - \"H\": Design matrix (Jacobian)\n        - \"W\": Weight matrix\n        These can be used to compute Dilution of Precision (DOP) metrics. Default is False.\n    enable_torch (bool, optional): \n        Whether to use PyTorch backend for computations. When True,\n        the function uses PyTorch tensors and operations, allowing gradients to flow through the\n        computation graph. This enables the use of this function in neural network training, where\n        weights (w) and bias (b) can be optimized using gradient descent. Default is False.\n    w (array-like, optional): Weight matrix for pseudorange observations. If enable_torch=True,\n        gradients will propagate through w to the position solution, allowing wp to be optimized\n        in neural networks. Default is None (uses inverse of observation variance).\n    b (array-like, optional): Bias vector to be subtracted from pseudorange observations. If\n        enable_torch=True, gradients will propagate through b to the position solution, allowing\n        b to be optimized in neural networks. Default is None (zero vector).\n    device (str, optional): Device to run PyTorch computations on ('cpu' or 'cuda'). Default is 'cpu'.\n\n    Returns:\n    dict: A dictionary containing positioning results, status, and additional information with keys:\n        - \"status\" (bool): True if positioning succeeded, False otherwise\n        - \"pos\" (array): Receiver position [x, y, z] in ECEF coordinates\n        - \"cb\" (array): Receiver clock bias for each GNSS system\n        - \"cd\" (array): Receiver clock drift\n        - \"msg\" (str): Status message\n        - \"data\" (array): Processed observation data\n        - \"solve_data\" (dict): Preprocessed data used in solving\n        - \"raw_data\" (dict): Raw observation data\n        - \"residual_info\" (dict, optional): Residuals and Jacobian matrix if return_residual=True\n    \"\"\"\n    maxiter = 20\n    o_id = id(o)\n    if use_cache and o_id in cache_data:\n        p, p_t, v, v_t, data, cdata, raw_data = cache_data[o_id]\n    else:\n        p, p_t, v, v_t, data, cdata, raw_data = preprocess_obs(o, nav, use_cache)\n\n    # test cdata['sys'], check the number of systems and the number of unknowns\n    if np.unique(cdata['sys']).shape[0] + 3 &gt; cdata['pr'].shape[0]:\n        return {\n            \"status\": False,\n            \"pos\": np.zeros(4),\n            \"msg\": \"insufficient satellites for the number of systems\",\n            \"data\": {},\n            \"solve_data\": cdata,\n            \"raw_data\": raw_data\n        }\n\n\n    iter = 0\n\n    backend = Backend(enable_torch)\n\n    def ensure_array(x, shape, dtype=backend.float64):\n        if x is None:\n            return backend.zeros(shape, dtype=dtype)\n        return backend.asarray(x, dtype=dtype).reshape(shape)\n\n    # initalize variables\n    p = ensure_array(p, (3,))\n    p_t = ensure_array(p_t, (len(SYS_NAME),))\n\n\n    # ensure all variables are on the correct device\n    p = backend.to(p, device)\n    p_t = backend.to(p_t, device)\n\n    dp = backend.asarray(np.array(100.0), dtype=backend.float64)\n    dp = backend.to(dp, device)\n\n    # construct p_t_mask\n    idx = backend.array([list(SYS_NAME).index(s) for s in data[:,2]], dtype=backend.int64)  # \u7d22\u5f15\u7528 int64\n    eye_matrix = backend.eye(len(SYS_NAME), dtype=backend.float64)\n    p_t_mask = eye_matrix[idx] \n    p_t_mask = backend.to(p_t_mask, device)\n\n    # process b\n    if b is None:\n        b = backend.zeros_like(backend.asarray(cdata['pr']), dtype=backend.float64)\n    else:\n        b = backend.asarray(b, dtype=backend.float64).reshape(-1,1)\n    b = backend.to(b, device)\n\n    # process Wpr\n    if w is not None:\n        if isinstance(w, (int, float)) and w == 1:\n            W_pr = backend.eye(len(cdata['pr']), dtype=backend.float64)\n        else:\n            w_tensor = backend.asarray(w, dtype=backend.float64)\n            W_pr = backend.diag(w_tensor)\n    else:\n        var = backend.asarray(cdata['var'], dtype=backend.float64)\n        W_pr = backend.diag(1.0 / backend.sqrt(var))\n\n\n    W = backend.to(W_pr, device)\n\n    # ensure cdata pr and dop are tensors on the correct device\n    pr_tensor = backend.asarray(cdata['pr'], dtype=backend.float64)\n    pr_tensor = backend.to(pr_tensor, device)\n\n    try:\n        while iter &lt; maxiter and backend.linalg_norm(dp) &gt; 0.001:\n            psr, H = pseudorange_observe_func(\n                p, backend.dot(p_t_mask, p_t), cdata['satpos'][:,:3], cdata[\"sdt\"][:,0],\n                cdata['I'], cdata['T'], cdata['sagnac'], cdata['sys'], enable_torch=enable_torch,\n                device=device\n            )\n\n\n            p_residual = pr_tensor - psr - b\n            residual = p_residual\n\n\n            # solve least squares\n            W_H = backend.dot(W, H)\n            W_r = backend.dot(W, residual)\n            result = backend.linalg_lstsq(W_H, W_r, rcond=None)\n            dp = result.solution if hasattr(result, 'solution') else result[0]\n\n            # update\n            p = p + backend.squeeze(dp[:3])\n            p_t = p_t + backend.squeeze(dp[3:])\n            iter += 1\n\n    except Exception as e:\n        zero_pos = backend.zeros(4, dtype=backend.float64)\n        zero_pos = backend.to(zero_pos, device)\n        return {\n            \"status\": False,\n            \"pos\": zero_pos,\n            \"msg\": str(e),\n            \"data\": {},\n            \"solve_data\": cdata,\n            \"raw_data\": raw_data\n        }\n\n    if iter &gt;= maxiter or backend.linalg_norm(dp) &gt; 1e-3:\n        zero_pos = backend.zeros(4, dtype=backend.float64)\n        zero_pos = backend.to(zero_pos, device)\n        return {\n            \"status\": False,\n            \"pos\": zero_pos,\n            \"msg\": \"not converge\",\n            \"data\": {},\n            \"solve_data\": cdata,\n            \"raw_data\": raw_data\n        }\n\n    # store to cache\n    cache_data[o_id][0] = backend.to_numpy(p)\n    cache_data[o_id][1] = backend.to_numpy(p_t)\n\n\n    # optional: return residuals and H\n    if return_residual:\n        psr, H = pseudorange_observe_func(\n            p, backend.dot(p_t_mask, p_t), cdata['satpos'][:,:3], cdata[\"sdt\"][:,0],\n            cdata['I'], cdata['T'], cdata['sagnac'], cdata['sys'], enable_torch=enable_torch\n        )\n\n        pr_tensor = backend.asarray(cdata['pr'], dtype=backend.float64)\n        pr_tensor = backend.to(pr_tensor, device)\n\n        residual = pr_tensor - psr - b\n        residual_info = {\n            \"residual\": residual,\n            \"H\": H,\n            \"W\": W\n        }\n    else:\n        residual_info = {}\n\n    return {\n        \"status\": True,\n        \"pos\": p,\n        \"cb\": p_t,\n        \"msg\": \"ok\",\n        \"data\": data,\n        \"solve_data\": cdata,\n        \"raw_data\": raw_data,\n        \"residual_info\": residual_info\n    }\n</code></pre>"},{"location":"api/#tasgnss.wls_pnt_pos_vel","title":"<code>wls_pnt_pos_vel(o, nav, use_cache=True, return_residual=False, enable_torch=False, wp=None, wv=None, b=None, device='cpu')</code>","text":"<p>Performs Weighted Least Squares (WLS) positioning using GNSS observations.</p> <p>This function implements an iterative WLS algorithm to solve for receiver position, velocity, and clock parameters. It supports caching for performance optimization and PyTorch backend for gradient-based optimization.</p> <p>Key Features: - Uses caching to accelerate repeated calls with the same observation data - Supports PyTorch backend for gradient propagation, enabling use in neural network optimization - Handles multiple GNSS constellations with separate clock bias parameters - Includes atmospheric and relativistic corrections</p> <p>o (obs_t):      GNSS observation data structure for one epoch. nav (nav_t):      Navigation data structure with ephemerides and satellite biases. use_cache (bool, optional):      Whether to use cached preprocessing results. When True, if the same     observation object is processed multiple times, the preprocessing results (satellite positions,     atmospheric corrections, etc.) are cached and reused, significantly speeding up repeated calls.     Default is True. return_residual (bool, optional):      Whether to return residuals, Jacobian matrix, and weight matrix.     When True, the returned dictionary includes a \"residual_info\" key containing:     - \"residual\": Observation residuals vector     - \"H\": Design matrix (Jacobian)     - \"W\": Weight matrix     These can be used to compute Dilution of Precision (DOP) metrics. Default is False. enable_torch (bool, optional):      Whether to use PyTorch backend for computations. When True,     the function uses PyTorch tensors and operations, allowing gradients to flow through the     computation graph. This enables the use of this function in neural network training, where     weights (wp, wv) and bias (b) can be optimized using gradient descent. Default is False. wp (array-like, optional): Weight matrix for pseudorange observations. If enable_torch=True,     gradients will propagate through wp to the position solution, allowing wp to be optimized     in neural networks. Default is None (uses inverse of observation variance). wv (array-like, optional): Weight matrix for Doppler observations. If enable_torch=True,     gradients will propagate through wv to the position solution. Default is None (uses wp*10). b (array-like, optional): Bias vector to be subtracted from pseudorange observations. If     enable_torch=True, gradients will propagate through b to the position solution, allowing     b to be optimized in neural networks. Default is None (zero vector). device (str, optional): Device to run PyTorch computations on ('cpu' or 'cuda'). Default is 'cpu'.</p> <p>dict: A dictionary containing positioning results, status, and additional information with keys:     - \"status\" (bool): True if positioning succeeded, False otherwise     - \"pos\" (array): Receiver position [x, y, z] in ECEF coordinates     - \"velocity\" (array): Receiver velocity [vx, vy, vz] in ECEF coordinates     - \"cb\" (array): Receiver clock bias for each GNSS system     - \"cd\" (array): Receiver clock drift     - \"msg\" (str): Status message     - \"data\" (array): Processed observation data     - \"solve_data\" (dict): Preprocessed data used in solving     - \"raw_data\" (dict): Raw observation data     - \"residual_info\" (dict, optional): Residuals and Jacobian matrix if return_residual=True</p> Source code in <code>tasgnss/core.py</code> <pre><code>def wls_pnt_pos_vel(o, nav, use_cache=True, return_residual=False, enable_torch=False, wp=None, wv=None, b=None, device='cpu'):\n    \"\"\"\n    Performs Weighted Least Squares (WLS) positioning using GNSS observations.\n\n    This function implements an iterative WLS algorithm to solve for receiver position, velocity,\n    and clock parameters. It supports caching for performance optimization and PyTorch backend\n    for gradient-based optimization.\n\n    Key Features:\n    - Uses caching to accelerate repeated calls with the same observation data\n    - Supports PyTorch backend for gradient propagation, enabling use in neural network optimization\n    - Handles multiple GNSS constellations with separate clock bias parameters\n    - Includes atmospheric and relativistic corrections\n\n    Parameters:\n    o (obs_t): \n        GNSS observation data structure for one epoch.\n    nav (nav_t): \n        Navigation data structure with ephemerides and satellite biases.\n    use_cache (bool, optional): \n        Whether to use cached preprocessing results. When True, if the same\n        observation object is processed multiple times, the preprocessing results (satellite positions,\n        atmospheric corrections, etc.) are cached and reused, significantly speeding up repeated calls.\n        Default is True.\n    return_residual (bool, optional): \n        Whether to return residuals, Jacobian matrix, and weight matrix.\n        When True, the returned dictionary includes a \"residual_info\" key containing:\n        - \"residual\": Observation residuals vector\n        - \"H\": Design matrix (Jacobian)\n        - \"W\": Weight matrix\n        These can be used to compute Dilution of Precision (DOP) metrics. Default is False.\n    enable_torch (bool, optional): \n        Whether to use PyTorch backend for computations. When True,\n        the function uses PyTorch tensors and operations, allowing gradients to flow through the\n        computation graph. This enables the use of this function in neural network training, where\n        weights (wp, wv) and bias (b) can be optimized using gradient descent. Default is False.\n    wp (array-like, optional): Weight matrix for pseudorange observations. If enable_torch=True,\n        gradients will propagate through wp to the position solution, allowing wp to be optimized\n        in neural networks. Default is None (uses inverse of observation variance).\n    wv (array-like, optional): Weight matrix for Doppler observations. If enable_torch=True,\n        gradients will propagate through wv to the position solution. Default is None (uses wp*10).\n    b (array-like, optional): Bias vector to be subtracted from pseudorange observations. If\n        enable_torch=True, gradients will propagate through b to the position solution, allowing\n        b to be optimized in neural networks. Default is None (zero vector).\n    device (str, optional): Device to run PyTorch computations on ('cpu' or 'cuda'). Default is 'cpu'.\n\n    Returns:\n    dict: A dictionary containing positioning results, status, and additional information with keys:\n        - \"status\" (bool): True if positioning succeeded, False otherwise\n        - \"pos\" (array): Receiver position [x, y, z] in ECEF coordinates\n        - \"velocity\" (array): Receiver velocity [vx, vy, vz] in ECEF coordinates\n        - \"cb\" (array): Receiver clock bias for each GNSS system\n        - \"cd\" (array): Receiver clock drift\n        - \"msg\" (str): Status message\n        - \"data\" (array): Processed observation data\n        - \"solve_data\" (dict): Preprocessed data used in solving\n        - \"raw_data\" (dict): Raw observation data\n        - \"residual_info\" (dict, optional): Residuals and Jacobian matrix if return_residual=True\n    \"\"\"\n    maxiter = 20\n    o_id = id(o)\n    if use_cache and o_id in cache_data:\n        p, p_t, v, v_t, data, cdata, raw_data = cache_data[o_id]\n    else:\n        p, p_t, v, v_t, data, cdata, raw_data = preprocess_obs(o, nav, use_cache)\n    iter = 0\n\n    backend = Backend(enable_torch)\n\n    def ensure_array(x, shape, dtype=backend.float64):\n        if x is None:\n            return backend.zeros(shape, dtype=dtype)\n        return backend.asarray(x, dtype=dtype).reshape(shape)\n\n    # initalize variables\n    p = ensure_array(p, (3,))\n    p_t = ensure_array(p_t, (len(SYS_NAME),))\n    v = ensure_array(v, (3,))\n    v_t = ensure_array(v_t, (1,))\n\n    # ensure all variables are on the correct device\n    p = backend.to(p, device)\n    p_t = backend.to(p_t, device)\n    v = backend.to(v, device)\n    v_t = backend.to(v_t, device)\n\n    dp = backend.asarray(np.array(100.0), dtype=backend.float64)\n    dp = backend.to(dp, device)\n\n    # construct p_t_mask\n    idx = backend.array([list(SYS_NAME).index(s) for s in data[:,2]], dtype=backend.int64)  # \u7d22\u5f15\u7528 int64\n    eye_matrix = backend.eye(len(SYS_NAME), dtype=backend.float64)\n    p_t_mask = eye_matrix[idx] \n    p_t_mask = backend.to(p_t_mask, device)\n\n    # process b\n    if b is None:\n        b = backend.zeros_like(backend.asarray(cdata['pr']), dtype=backend.float64)\n    else:\n        b = backend.asarray(b, dtype=backend.float64).reshape(-1,1)\n    b = backend.to(b, device)\n\n    # process Wpr\n    if wp is not None:\n        if isinstance(wp, (int, float)) and wp == 1:\n            W_pr = backend.eye(len(cdata['pr']), dtype=backend.float64)\n        else:\n            wp_tensor = backend.asarray(wp, dtype=backend.float64)\n            W_pr = backend.diag(wp_tensor)\n    else:\n        var = backend.asarray(cdata['var'], dtype=backend.float64)\n        W_pr = backend.diag(1.0 / backend.sqrt(var))\n\n    # process Wdop\n    if wv is not None:\n        wv_tensor = backend.asarray(wv, dtype=backend.float64)\n        W_dop = backend.diag(wv_tensor)\n    else:\n        W_dop = W_pr * 100.0 \n\n    # combine W\n    W = backend.block_diag(W_pr, W_dop)\n    W = backend.to(W, device)\n\n    # ensure cdata pr and dop are tensors on the correct device\n    pr_tensor = backend.asarray(cdata['pr'], dtype=backend.float64)\n    dop_tensor = backend.asarray(cdata['dop'], dtype=backend.float64)\n    pr_tensor = backend.to(pr_tensor, device)\n    dop_tensor = backend.to(dop_tensor, device)\n\n    try:\n        while iter &lt; maxiter and backend.linalg_norm(dp) &gt; 0.001:\n            psr, H_psr = pseudorange_observe_func(\n                p, backend.dot(p_t_mask, p_t), cdata['satpos'][:,:3], cdata[\"sdt\"][:,0],\n                cdata['I'], cdata['T'], cdata['sagnac'], cdata['sys'], enable_torch=enable_torch,\n                device=device\n            )\n            dop, H_dop = doppler_observe_func(\n                v, v_t, p, cdata['satpos'][:,:3], cdata['satpos'][:,3:],\n                cdata[\"sdt\"][:,1], cdata['sys'], enable_torch=enable_torch,\n                device=device\n            )\n\n\n            p_residual = pr_tensor - psr - b\n            d_residual = dop_tensor - dop\n            residual = backend.vstack((p_residual, d_residual))\n            H = backend.block_diag(H_psr, H_dop)\n\n\n            # solve least squares\n            W_H = backend.dot(W, H)\n            W_r = backend.dot(W, residual)\n            result = backend.linalg_lstsq(W_H, W_r, rcond=None)\n            dp = result.solution if hasattr(result, 'solution') else result[0]\n\n            # update\n            p = p + backend.squeeze(dp[:3])\n            p_t = p_t + backend.squeeze(dp[3:-4])\n            v = v + backend.squeeze(dp[-4:-1])\n            v_t = v_t + backend.squeeze(dp[-1:])\n            iter += 1\n\n    except Exception as e:\n        zero_pos = backend.zeros(4, dtype=backend.float64)\n        zero_pos = backend.to(zero_pos, device)\n        return {\n            \"status\": False,\n            \"pos\": zero_pos,\n            \"msg\": str(e),\n            \"data\": {},\n            \"solve_data\": cdata,\n            \"raw_data\": raw_data\n        }\n\n    if iter &gt;= maxiter or backend.linalg_norm(dp) &gt; 1e-3:\n        zero_pos = backend.zeros(4, dtype=backend.float64)\n        zero_pos = backend.to(zero_pos, device)\n        return {\n            \"status\": False,\n            \"pos\": zero_pos,\n            \"msg\": \"not converge\",\n            \"data\": {},\n            \"solve_data\": cdata,\n            \"raw_data\": raw_data\n        }\n\n    # store to cache\n    cache_data[o_id][0] = backend.to_numpy(p)\n    cache_data[o_id][1] = backend.to_numpy(p_t)\n    cache_data[o_id][2] = backend.to_numpy(v)\n    cache_data[o_id][3] = backend.to_numpy(v_t)\n\n    # optional: return residuals and H\n    if return_residual:\n        psr, Hp = pseudorange_observe_func(\n            p, backend.dot(p_t_mask, p_t), cdata['satpos'][:,:3], cdata[\"sdt\"][:,0],\n            cdata['I'], cdata['T'], cdata['sagnac'], cdata['sys'], enable_torch=enable_torch\n        )\n        dop, Hd = doppler_observe_func(\n            v, v_t, p, cdata['satpos'][:,:3], cdata['satpos'][:,3:],\n            cdata[\"sdt\"][:,1], cdata['sys'], enable_torch=enable_torch\n        )\n\n        pr_tensor = backend.asarray(cdata['pr'], dtype=backend.float64)\n        dop_tensor = backend.asarray(cdata['dop'], dtype=backend.float64)\n        pr_tensor = backend.to(pr_tensor, device)\n        dop_tensor = backend.to(dop_tensor, device)\n\n        residual_p = pr_tensor - psr - b\n        residual_d = dop_tensor - dop\n        residual = backend.vstack((residual_p, residual_d))\n        H = backend.block_diag(Hp, Hd)\n        residual_info = {\n            \"residual\": residual,\n            \"H\": H,\n            \"W\": W\n        }\n    else:\n        residual_info = {}\n\n    return {\n        \"status\": True,\n        \"pos\": p,\n        \"velocity\": v,\n        \"cb\": p_t,\n        'cd': v_t,\n        \"msg\": \"ok\",\n        \"data\": data,\n        \"solve_data\": cdata,\n        \"raw_data\": raw_data,\n        \"residual_info\": residual_info\n    }\n</code></pre>"},{"location":"api/#tasgnss.xyz2enu","title":"<code>xyz2enu(pos, deg=True)</code>","text":"<p>Convert ECEF coordinates to ENU rotation matrix Parameters:     pos: tuple or array of (lat, lon) in degrees or radians     deg: if True, pos is in degrees, else in radians Returns:     E: 3x3 rotation matrix from ECEF to ENU</p> Source code in <code>tasgnss/core.py</code> <pre><code>def xyz2enu(pos, deg=True):\n    \"\"\"\n    Convert ECEF coordinates to ENU rotation matrix\n    Parameters:\n        pos: tuple or array of (lat, lon) in degrees or radians\n        deg: if True, pos is in degrees, else in radians\n    Returns:\n        E: 3x3 rotation matrix from ECEF to ENU\n    \"\"\"\n    E = prl.Arr1Ddouble(9)\n    _pos = prl.Arr1Ddouble(2)\n    if deg:\n        _pos[0] = pos[0] * prl.D2R\n        _pos[1] = pos[1] * prl.D2R\n        prl.xyz2enu(_pos, E)\n    else:\n        _pos[0] = pos[0]\n        _pos[1] = pos[1]\n        prl.xyz2enu(_pos, E)\n    return np.array(E).reshape(3, 3)\n</code></pre>"},{"location":"appendix/","title":"Appendix","text":"<p>This is not an academic material, and the objective of this README is just to briefly introduce the GNSS principles to beginners, and the most important, to let beginners quickly run up the GNSS positioning.</p>"},{"location":"appendix/#basic-ideal-gnss-model","title":"Basic ideal GNSS model","text":"\\[ P = r + C(\\delta{t_r}-\\delta{t^s}) + I + T + \\epsilon \\] \\[ r = \\sqrt{{(x^s-x_r)}^2+{(y^s-y_r)}^2+{(z^s-z_r)}^2}+sagnac \\] <p>where \\(r\\) is the geomitric distance between the satellite and the receiver, \\(x^s,y^s,z^s\\) are the satellite's coordinates in ECEF and \\(x_r,y_r,z_r\\) are the receiver's coordinates in ECEF. \\(P\\) is the pseudorange and \\(C\\) is the speed of light. \\(\\delta{t_r}\\) and \\(\\delta{t^s}\\) represent the receiver clock bias and satellite clock bias, respectively. \\(I\\) is the ionospheric delay and \\(T\\) is the troposiphere deley. \\(\\epsilon\\) denotes the gaussian white noise.</p>"},{"location":"appendix/#basic-weighted-least-squares-solution","title":"Basic weighted least squares solution","text":"<p>A typical GNSS positioning process is to solve the receiver's position - the \\(x_r,y_r,z_r\\) in equation (1). We assume we only need to solve the four unknowns, including \\(x_r,y_r,z_r\\) and \\(\\delta{t_r}\\). (If you are doing PPP, then other paramerters are also need to be estimated, here is just a brief introduction to GNSS single point positioning.). The observation function is defined below:</p> \\[ \\hat{P}_i = h_i(x,y,z,\\delta{t})  \\] <p>Here, \\(i\\) denotes the \\(i_{th}\\) satellite. This means the number of the observation functions is equal to the number of satellites and the measurements.</p>"},{"location":"appendix/#wls-solution-process","title":"WLS Solution Process","text":"<p>Linearize the observation equation at the current state estimate \\(\\mathbf{x}_0 = [x_r, y_r, z_r, \\delta{t_r}]^T\\):</p> \\[ P_i = h_i(\\mathbf{x}_0) + \\frac{\\partial h_i}{\\partial \\mathbf{x}}\\bigg|_{\\mathbf{x}_0} \\Delta\\mathbf{x} + \\epsilon_i \\] <p>Expressed in matrix form, where \\(\\mathbf{P}\\) is the vector of residuals \\(P_i - h_i(\\mathbf{x}_0)\\):</p> \\[ \\mathbf{P} = \\mathbf{H} \\Delta\\mathbf{x} + \\mathbf{\\epsilon} \\] <p>where \\(\\mathbf{H}\\) is the design matrix (Jacobian matrix), and \\(\\Delta\\mathbf{x}\\) is the state increment. The weighted least squares solution is:</p> \\[ \\Delta\\mathbf{x} = (\\mathbf{H}^T \\mathbf{W} \\mathbf{H})^{-1} \\mathbf{H}^T \\mathbf{W} \\mathbf{P} \\] <p>where \\(\\mathbf{W}\\) is the weight matrix, typically the inverse of the observation variance. In practice, the code uses <code>backend.linalg_lstsq</code> to directly solve \\(\\mathbf{W}\\mathbf{H} \\Delta\\mathbf{x} = \\mathbf{W}\\mathbf{P}\\), avoiding explicit matrix inversion.</p> <p>After solving for \\(\\Delta\\mathbf{x}\\), the state vector is updated as: \\(\\mathbf{x} = \\mathbf{x}_0 + \\Delta\\mathbf{x}\\). This process is iterated until convergence \\(||\\Delta{x}&lt;10^{-4}||\\).</p>"},{"location":"appendix/#corrections-required-in-practical-gnss-applications","title":"Corrections Required in Practical GNSS Applications","text":"<p>In practical GNSS positioning, besides the basic geometric distance and clock bias, the following corrections need to be considered:</p> <ol> <li>Ionospheric Delay (I): Delay caused by signal propagation through the ionosphere, inversely proportional to the square of the frequency. Obtained from <code>get_atmosphere_delay</code> in preprocessing.</li> <li>Tropospheric Delay (T): Delay caused by signal propagation through the troposphere, related to elevation angle and meteorological conditions. Obtained from <code>get_atmosphere_delay</code> in preprocessing.</li> <li>Satellite Clock Bias (\\(\\delta{t^s}\\)): Deviation of the satellite atomic clock from system time, provided by navigation messages. Obtained from <code>get_sat_pos</code>.</li> <li>Relativistic Effects: Includes relativistic frequency shift of satellite clocks and Sagnac effect during signal propagation. Corrected in RTKLIB's <code>satpos</code> function; the satellite positions obtained are already corrected.</li> <li>Earth Rotation Correction: Coordinate system changes due to Earth's rotation during signal propagation, corrected by Sagnac effect using <code>get_sagnac_corr</code>.</li> </ol> <p>In the code implementation, these corrections are already accounted for in <code>pseudorange_observe_func</code> and <code>doppler_observe_func</code>.</p>"},{"location":"appendix/#example-usage","title":"Example Usage","text":"<p>Here's an example of how to use the preprocessing and observation functions to obtain corrected observations:</p> <pre><code># Step 1: Preprocess observations to obtain corrections\nfrom tasgnss import preprocess_obs, pseudorange_observe_func, doppler_observe_func\n\n# Assuming 'o' is your observation data and 'nav' is navigation data\np, p_t, v, v_t, data, cdata, raw_data = preprocess_obs(o, nav, use_cache=True)\n\n# The 'cdata' dictionary contains all necessary corrections:\n# - cdata['satpos'][:,:3]: Satellite positions (already corrected for relativistic effects)\n# - cdata['sdt'][:,0]: Satellite clock biases (from get_sat_pos)\n# - cdata['I']: Ionospheric delays (from get_atmosphere_delay)\n# - cdata['T']: Tropospheric delays (from get_atmosphere_delay)\n# - cdata['sagnac']: Sagnac correction (Earth rotation correction)\n\n# Step 2: Use observation functions to compute estimated pseudoranges and Doppler\n# Initialize receiver position and clock bias\nimport numpy as np\npos = np.array([x0, y0, z0])  # Initial position estimate\nclock_bias = np.zeros(len(SYS_NAME))  # Clock bias for each GNSS system\n\n# Create system mask for clock bias\nfrom tasgnss import SYS_NAME\np_t_mask = np.eye(len(SYS_NAME))[np.array([list(SYS_NAME).index(s) for s in cdata['sys']])]\n\n# Compute estimated pseudoranges\nestimated_psr, H_psr = pseudorange_observe_func(\n    pos,\n    np.dot(p_t_mask, clock_bias),\n    cdata['satpos'][:,:3],\n    cdata[\"sdt\"][:,0],\n    cdata['I'],\n    cdata['T'],\n    cdata['sagnac'],\n    cdata['sys']\n)\n\n# Compute estimated Doppler\nestimated_dop, H_dop = doppler_observe_func(\n    v,  # Velocity estimate\n    v_t,  # Clock drift estimate\n    pos,\n    cdata['satpos'][:,:3],\n    cdata['satpos'][:,3:],\n    cdata[\"sdt\"][:,1],\n    cdata['sys']\n)\n\n# The residuals can be computed as:\nresidual_psr = cdata['pr'] - estimated_psr\nresidual_dop = cdata['dop'] - estimated_dop\n</code></pre> <p>This example shows how the various corrections are obtained through preprocessing and then applied in the observation functions to compute estimated observations.</p>"},{"location":"appendix/#dilution-of-precision-dop","title":"Dilution of Precision (DOP)","text":"<p>Dilution of Precision (DOP) is a measure of how satellite geometry affects positioning accuracy. Poor satellite geometry (e.g., all satellites clustered in one part of the sky) results in higher DOP values and lower positioning accuracy, while good satellite geometry (e.g., satellites well-distributed across the sky) results in lower DOP values and higher positioning accuracy.</p> <p>The most common DOP metrics are: - GDOP (Geometric DOP): Overall effect on 3D position and time - PDOP (Position DOP): Effect on 3D position (x, y, z) - HDOP (Horizontal DOP): Effect on horizontal position (x, y) - VDOP (Vertical DOP): Effect on vertical position (z) - TDOP (Time DOP): Effect on time solution</p>"},{"location":"appendix/#dop-calculation","title":"DOP Calculation","text":"<p>DOP values can be calculated from the covariance matrix of the estimated parameters. The covariance matrix is computed as:</p> \\[ \\mathbf{C} = (\\mathbf{H}^T \\mathbf{W} \\mathbf{H})^{-1} \\] <p>where \\(\\mathbf{H}\\) is the design matrix (Jacobian) and \\(\\mathbf{W}\\) is the weight matrix.</p> <p>The DOP values are then calculated as:</p> <ul> <li>GDOP = \\(\\sqrt{C_{11} + C_{22} + C_{33} + C_{44}}\\)</li> <li>PDOP = \\(\\sqrt{C_{11} + C_{22} + C_{33}}\\)</li> <li>HDOP = \\(\\sqrt{C_{11} + C_{22}}\\)</li> <li>VDOP = \\(\\sqrt{C_{33}}\\)</li> <li>TDOP = \\(\\sqrt{C_{44}}\\)</li> </ul>"},{"location":"appendix/#using-wls_pnt_pos-for-dop-calculation","title":"Using wls_pnt_pos for DOP Calculation","text":"<p>The <code>wls_pnt_pos</code> function can be used to calculate DOP by setting <code>return_residual=True</code>. This returns the design matrix \\(\\mathbf{H}\\) and weight matrix \\(\\mathbf{W}\\) in the <code>residual_info</code> dictionary, which can then be used to compute the covariance matrix and DOP values:</p> <pre><code>result = wls_pnt_pos(o, nav, return_residual=True)\nif result[\"status\"]:\n    H = result[\"residual_info\"][\"H\"]\n    W = result[\"residual_info\"][\"W\"]\n    # Compute covariance matrix\n    C = np.linalg.inv(H.T @ W @ H)\n    # Extract DOP values\n    GDOP = np.sqrt(C[0,0] + C[1,1] + C[2,2] + C[3,3])\n    PDOP = np.sqrt(C[0,0] + C[1,1] + C[2,2])\n    HDOP = np.sqrt(C[0,0] + C[1,1])\n    VDOP = np.sqrt(C[2,2])\n    TDOP = np.sqrt(C[3,3])\n</code></pre>"}]}